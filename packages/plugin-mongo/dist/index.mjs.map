{"version":3,"file":"index.mjs","sources":["../src/mongo.ts","../src/utils.ts","../src/persistence.ts","../src/storage.ts","../src/index.ts"],"sourcesContent":["import type { Cursor } from \"@apibara/protocol\";\nimport type { ClientSession, Db } from \"mongodb\";\n\nexport async function invalidate(\n  db: Db,\n  session: ClientSession,\n  cursor: Cursor,\n  collections: string[],\n) {\n  const orderKeyValue = Number(cursor.orderKey);\n  for (const collection of collections) {\n    // Delete documents where the lower bound of _cursor is greater than the invalidate cursor\n    await db.collection(collection).deleteMany(\n      {\n        \"_cursor.from\": {\n          $gt: orderKeyValue,\n        },\n      },\n      { session },\n    );\n\n    // Update documents where the upper bound of _cursor is greater than the invalidate cursor\n    await db.collection(collection).updateMany(\n      { \"_cursor.to\": { $gt: orderKeyValue } },\n      {\n        $set: {\n          \"_cursor.to\": null,\n        },\n      },\n      { session },\n    );\n  }\n}\n\nexport async function finalize(\n  db: Db,\n  session: ClientSession,\n  cursor: Cursor,\n  collections: string[],\n) {\n  const orderKeyValue = Number(cursor.orderKey);\n  for (const collection of collections) {\n    // Delete documents where the upper bound of _cursor is less than the finalize cursor\n    await db.collection(collection).deleteMany(\n      {\n        \"_cursor.to\": { $lte: orderKeyValue },\n      },\n      { session },\n    );\n  }\n}\n\nexport async function cleanupStorage(\n  db: Db,\n  session: ClientSession,\n  collections: string[],\n) {\n  for (const collection of collections) {\n    try {\n      // Delete all documents in the collection\n      await db.collection(collection).deleteMany({}, { session });\n    } catch (error) {\n      throw new Error(`Failed to clean up collection ${collection}`, {\n        cause: error,\n      });\n    }\n  }\n}\n","import type { ClientSession, MongoClient } from \"mongodb\";\n\nexport class MongoStorageError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = \"MongoStorageError\";\n  }\n}\n\nexport async function withTransaction<T>(\n  client: MongoClient,\n  cb: (session: ClientSession) => Promise<T>,\n) {\n  return await client.withSession(async (session) => {\n    return await session.withTransaction(\n      async (session) => {\n        return await cb(session);\n      },\n      {\n        retryWrites: false,\n      },\n    );\n  });\n}\n","import { type Cursor, normalizeCursor } from \"@apibara/protocol\";\nimport type { ClientSession, Db } from \"mongodb\";\nimport { MongoStorageError } from \"./utils\";\n\nexport type CheckpointSchema = {\n  id: string;\n  orderKey: number;\n  uniqueKey: string | null;\n};\n\nexport type FilterSchema = {\n  id: string;\n  filter: Record<string, unknown>;\n  fromBlock: number;\n  toBlock: number | null;\n};\n\nexport const checkpointCollectionName = \"checkpoints\";\nexport const filterCollectionName = \"filters\";\n\nexport async function initializePersistentState(\n  db: Db,\n  session: ClientSession,\n) {\n  const checkpoint = db.collection<CheckpointSchema>(checkpointCollectionName);\n  const filter = db.collection<FilterSchema>(filterCollectionName);\n\n  await checkpoint.createIndex({ id: 1 }, { session });\n  await filter.createIndex({ id: 1, fromBlock: 1 }, { session });\n}\n\nexport async function persistState<TFilter>(props: {\n  db: Db;\n  session: ClientSession;\n  endCursor: Cursor;\n  filter?: TFilter;\n  indexerId: string;\n}) {\n  const { db, session, endCursor, filter, indexerId } = props;\n\n  if (endCursor) {\n    await db.collection<CheckpointSchema>(checkpointCollectionName).updateOne(\n      { id: indexerId },\n      {\n        $set: {\n          orderKey: Number(endCursor.orderKey),\n          uniqueKey: endCursor.uniqueKey ? endCursor.uniqueKey : null,\n        },\n      },\n      { upsert: true, session },\n    );\n\n    if (filter) {\n      // Update existing filter's to_block\n      await db\n        .collection<FilterSchema>(filterCollectionName)\n        .updateMany(\n          { id: indexerId, toBlock: null },\n          { $set: { toBlock: Number(endCursor.orderKey) } },\n          { session },\n        );\n\n      // Insert new filter\n      await db.collection<FilterSchema>(filterCollectionName).updateOne(\n        {\n          id: indexerId,\n          fromBlock: Number(endCursor.orderKey),\n        },\n        {\n          $set: {\n            filter: filter as Record<string, unknown>,\n            fromBlock: Number(endCursor.orderKey),\n            toBlock: null,\n          },\n        },\n        { upsert: true, session },\n      );\n    }\n  }\n}\n\nexport async function getState<TFilter>(props: {\n  db: Db;\n  session: ClientSession;\n  indexerId: string;\n}): Promise<{ cursor?: Cursor; filter?: TFilter }> {\n  const { db, session, indexerId } = props;\n\n  let cursor: Cursor | undefined;\n  let filter: TFilter | undefined;\n\n  const checkpointRow = await db\n    .collection<CheckpointSchema>(checkpointCollectionName)\n    .findOne({ id: indexerId }, { session });\n\n  if (checkpointRow) {\n    cursor = normalizeCursor({\n      orderKey: BigInt(checkpointRow.orderKey),\n      uniqueKey: checkpointRow.uniqueKey,\n    });\n  }\n\n  const filterRow = await db\n    .collection<FilterSchema>(filterCollectionName)\n    .findOne(\n      {\n        id: indexerId,\n        toBlock: null,\n      },\n      { session },\n    );\n\n  if (filterRow) {\n    filter = filterRow.filter as TFilter;\n  }\n\n  return { cursor, filter };\n}\n\nexport async function invalidateState(props: {\n  db: Db;\n  session: ClientSession;\n  cursor: Cursor;\n  indexerId: string;\n}) {\n  const { db, session, cursor, indexerId } = props;\n\n  await db\n    .collection<FilterSchema>(filterCollectionName)\n    .deleteMany(\n      { id: indexerId, fromBlock: { $gt: Number(cursor.orderKey) } },\n      { session },\n    );\n\n  await db\n    .collection<FilterSchema>(filterCollectionName)\n    .updateMany(\n      { id: indexerId, toBlock: { $gt: Number(cursor.orderKey) } },\n      { $set: { toBlock: null } },\n      { session },\n    );\n}\n\nexport async function finalizeState(props: {\n  db: Db;\n  session: ClientSession;\n  cursor: Cursor;\n  indexerId: string;\n}) {\n  const { db, session, cursor, indexerId } = props;\n\n  await db.collection<FilterSchema>(filterCollectionName).deleteMany(\n    {\n      id: indexerId,\n      toBlock: { $lte: Number(cursor.orderKey) },\n    },\n    { session },\n  );\n}\n\nexport async function resetPersistence(props: {\n  db: Db;\n  session: ClientSession;\n  indexerId: string;\n}) {\n  const { db, session, indexerId } = props;\n\n  try {\n    // Delete all checkpoints for this indexer\n    await db\n      .collection<CheckpointSchema>(checkpointCollectionName)\n      .deleteMany({ id: indexerId }, { session });\n\n    // Delete all filters for this indexer\n    await db\n      .collection<FilterSchema>(filterCollectionName)\n      .deleteMany({ id: indexerId }, { session });\n  } catch (error) {\n    throw new MongoStorageError(\"Failed to reset persistence state\", {\n      cause: error,\n    });\n  }\n}\n","import type { Cursor } from \"@apibara/protocol\";\nimport type {\n  BulkWriteOptions,\n  ClientSession,\n  Collection,\n  CollectionOptions,\n  Db,\n  DeleteOptions,\n  Document,\n  Filter,\n  FindCursor,\n  FindOneAndUpdateOptions,\n  FindOptions,\n  InsertManyResult,\n  InsertOneOptions,\n  InsertOneResult,\n  MatchKeysAndValues,\n  OptionalUnlessRequiredId,\n  UpdateFilter,\n  UpdateOptions,\n  UpdateResult,\n  WithId,\n} from \"mongodb\";\n\nexport class MongoStorage {\n  constructor(\n    private db: Db,\n    private session: ClientSession,\n    private endCursor?: Cursor,\n  ) {}\n\n  collection<TSchema extends Document = Document>(\n    name: string,\n    options?: CollectionOptions,\n  ) {\n    const collection = this.db.collection<TSchema>(name, options);\n\n    return new MongoCollection<TSchema>(\n      this.session,\n      collection,\n      this.endCursor,\n    );\n  }\n}\n\nexport type MongoCursor = {\n  from: number | null;\n  to: number | null;\n};\n\nexport type CursoredSchema<TSchema extends Document> = TSchema & {\n  _cursor: MongoCursor;\n};\n\nexport class MongoCollection<TSchema extends Document> {\n  constructor(\n    private session: ClientSession,\n    private collection: Collection<TSchema>,\n    private endCursor?: Cursor,\n  ) {}\n\n  async insertOne(\n    doc: OptionalUnlessRequiredId<TSchema>,\n    options?: InsertOneOptions,\n  ): Promise<InsertOneResult<TSchema>> {\n    return await this.collection.insertOne(\n      {\n        ...doc,\n        _cursor: {\n          from: Number(this.endCursor?.orderKey),\n          to: null,\n        } as MongoCursor,\n      },\n      { ...options, session: this.session },\n    );\n  }\n\n  async insertMany(\n    docs: ReadonlyArray<OptionalUnlessRequiredId<TSchema>>,\n    options?: BulkWriteOptions,\n  ): Promise<InsertManyResult<TSchema>> {\n    return await this.collection.insertMany(\n      docs.map((doc) => ({\n        ...doc,\n        _cursor: {\n          from: Number(this.endCursor?.orderKey),\n          to: null,\n        } as MongoCursor,\n      })),\n      { ...options, session: this.session },\n    );\n  }\n\n  async updateOne(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: UpdateOptions,\n  ): Promise<UpdateResult<TSchema>> {\n    // 1. Find and update the document, getting the old version\n    const oldDoc = await this.collection.findOneAndUpdate(\n      {\n        ...filter,\n        \"_cursor.to\": null,\n      },\n      {\n        ...update,\n        $set: {\n          ...update.$set,\n          \"_cursor.from\": Number(this.endCursor?.orderKey),\n        } as unknown as MatchKeysAndValues<TSchema>,\n      },\n      {\n        ...options,\n        session: this.session,\n        returnDocument: \"before\",\n      } as FindOneAndUpdateOptions,\n    );\n\n    // 2. If we found and updated a document, insert its old version\n    if (oldDoc) {\n      const { _id, ...doc } = oldDoc;\n      await this.collection.insertOne(\n        {\n          ...doc,\n          _cursor: {\n            ...oldDoc._cursor,\n            to: Number(this.endCursor?.orderKey),\n          },\n        } as unknown as OptionalUnlessRequiredId<TSchema>,\n        { session: this.session },\n      );\n    }\n\n    // 3. Return an UpdateResult-compatible object\n    return {\n      acknowledged: true,\n      modifiedCount: oldDoc ? 1 : 0,\n      upsertedId: null,\n      upsertedCount: 0,\n      matchedCount: oldDoc ? 1 : 0,\n    };\n  }\n\n  async updateMany(\n    filter: Filter<TSchema>,\n    update: UpdateFilter<TSchema>,\n    options?: UpdateOptions,\n  ): Promise<UpdateResult<TSchema>> {\n    // 1. Find all documents matching the filter that are latest (to: null)\n    const oldDocs = await this.collection\n      .find(\n        {\n          ...filter,\n          \"_cursor.to\": null,\n        },\n        { session: this.session },\n      )\n      .toArray();\n\n    // 2. Update to the new values with updateMany\n    // (setting _cursor.from to endCursor, leaving _cursor.to unchanged)\n    const updateResult = await this.collection.updateMany(\n      {\n        ...filter,\n        \"_cursor.to\": null,\n      },\n      {\n        ...update,\n        $set: {\n          ...update.$set,\n          \"_cursor.from\": Number(this.endCursor?.orderKey),\n        } as unknown as MatchKeysAndValues<TSchema>,\n      },\n      { ...options, session: this.session },\n    );\n\n    // 3. Adjust the cursor.to of the old values\n    const oldDocsWithUpdatedCursor = oldDocs.map(({ _id, ...doc }) => ({\n      ...doc,\n      _cursor: {\n        ...doc._cursor,\n        to: Number(this.endCursor?.orderKey),\n      },\n    }));\n\n    // 4. Insert the old values back into the db\n    if (oldDocsWithUpdatedCursor.length > 0) {\n      await this.collection.insertMany(\n        oldDocsWithUpdatedCursor as unknown as OptionalUnlessRequiredId<TSchema>[],\n        { session: this.session },\n      );\n    }\n\n    return updateResult;\n  }\n\n  async deleteOne(\n    filter: Filter<TSchema>,\n    options?: DeleteOptions,\n  ): Promise<UpdateResult<TSchema>> {\n    return await this.collection.updateOne(\n      {\n        ...filter,\n        \"_cursor.to\": null,\n      },\n      {\n        $set: {\n          \"_cursor.to\": Number(this.endCursor?.orderKey),\n        } as unknown as MatchKeysAndValues<TSchema>,\n      },\n      { ...options, session: this.session },\n    );\n  }\n\n  async deleteMany(\n    filter?: Filter<TSchema>,\n    options?: DeleteOptions,\n  ): Promise<UpdateResult<TSchema>> {\n    return await this.collection.updateMany(\n      {\n        ...((filter ?? {}) as Filter<TSchema>),\n        \"_cursor.to\": null,\n      },\n      {\n        $set: {\n          \"_cursor.to\": Number(this.endCursor?.orderKey),\n        } as unknown as MatchKeysAndValues<TSchema>,\n      },\n      { ...options, session: this.session },\n    );\n  }\n\n  async findOne(\n    filter: Filter<TSchema>,\n    options?: Omit<FindOptions, \"timeoutMode\">,\n  ): Promise<WithId<TSchema> | null> {\n    return await this.collection.findOne(\n      {\n        ...filter,\n        \"_cursor.to\": null,\n      },\n      { ...options, session: this.session },\n    );\n  }\n\n  find(\n    filter: Filter<TSchema>,\n    options?: FindOptions,\n  ): FindCursor<WithId<TSchema>> {\n    return this.collection.find(\n      {\n        ...filter,\n        \"_cursor.to\": null,\n      },\n      { ...options, session: this.session },\n    );\n  }\n}\n","import { useIndexerContext } from \"@apibara/indexer\";\nimport { defineIndexerPlugin, useLogger } from \"@apibara/indexer/plugins\";\nimport type { DbOptions, MongoClient } from \"mongodb\";\n\nimport { generateIndexerId } from \"@apibara/indexer/internal\";\nimport { useInternalContext } from \"@apibara/indexer/internal/plugins\";\nimport type { Cursor, DataFinality } from \"@apibara/protocol\";\nimport { cleanupStorage, finalize, invalidate } from \"./mongo\";\nimport {\n  finalizeState,\n  getState,\n  initializePersistentState,\n  invalidateState,\n  persistState,\n  resetPersistence,\n} from \"./persistence\";\nimport { MongoStorage } from \"./storage\";\nimport { MongoStorageError, withTransaction } from \"./utils\";\n\nexport { MongoCollection, MongoStorage } from \"./storage\";\n\nconst MONGO_PROPERTY = \"_mongo\";\n\nexport function useMongoStorage(): MongoStorage {\n  const context = useIndexerContext();\n\n  if (!context[MONGO_PROPERTY]) {\n    throw new MongoStorageError(\n      \"mongo storage is not available. Did you register the plugin?\",\n    );\n  }\n\n  return context[MONGO_PROPERTY] as MongoStorage;\n}\n\nexport interface MongoStorageOptions {\n  client: MongoClient;\n  dbName: string;\n  dbOptions?: DbOptions;\n  collections: string[];\n  persistState?: boolean;\n  indexerName?: string;\n}\n/**\n * Creates a plugin that uses MongoDB as the storage layer.\n *\n * Supports storing the indexer's state and provides a simple Key-Value store.\n * @param options.client - The MongoDB client instance.\n * @param options.dbName - The name of the database.\n * @param options.dbOptions - The database options.\n * @param options.collections - The collections to use.\n * @param options.persistState - Whether to persist the indexer's state. Defaults to true.\n * @param options.indexerName - The name of the indexer. Defaults value is 'default'.\n */\nexport function mongoStorage<TFilter, TBlock>({\n  client,\n  dbName,\n  dbOptions,\n  collections,\n  persistState: enablePersistence = true,\n  indexerName: identifier = \"default\",\n}: MongoStorageOptions) {\n  return defineIndexerPlugin<TFilter, TBlock>((indexer) => {\n    let indexerId = \"\";\n    const alwaysReindex = process.env[\"APIBARA_ALWAYS_REINDEX\"] === \"true\";\n    let prevFinality: DataFinality | undefined;\n\n    indexer.hooks.hook(\"run:before\", async () => {\n      const { indexerName } = useInternalContext();\n      indexerId = generateIndexerId(indexerName, identifier);\n      const logger = useLogger();\n\n      await withTransaction(client, async (session) => {\n        const db = client.db(dbName, dbOptions);\n        if (enablePersistence) {\n          await initializePersistentState(db, session);\n        }\n\n        if (alwaysReindex) {\n          logger.warn(\n            `Reindexing: Deleting all data from collections - ${collections.join(\", \")}`,\n          );\n\n          await cleanupStorage(db, session, collections);\n\n          if (enablePersistence) {\n            await resetPersistence({ db, session, indexerId });\n          }\n\n          logger.success(\"All data has been cleaned up for reindexing\");\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"connect:before\", async ({ request }) => {\n      if (!enablePersistence) {\n        return;\n      }\n\n      await withTransaction(client, async (session) => {\n        const db = client.db(dbName, dbOptions);\n        const { cursor, filter } = await getState<TFilter>({\n          db,\n          session,\n          indexerId,\n        });\n\n        if (cursor) {\n          request.startingCursor = cursor;\n        }\n\n        if (filter) {\n          request.filter[1] = filter;\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"connect:after\", async ({ request }) => {\n      // On restart, we need to invalidate data for blocks that were processed but not persisted.\n      const cursor = request.startingCursor;\n\n      if (!cursor) {\n        return;\n      }\n\n      await withTransaction(client, async (session) => {\n        const db = client.db(dbName, dbOptions);\n        await invalidate(db, session, cursor, collections);\n\n        if (enablePersistence) {\n          await invalidateState({ db, session, cursor, indexerId });\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"connect:factory\", async ({ request, endCursor }) => {\n      if (!enablePersistence) {\n        return;\n      }\n      await withTransaction(client, async (session) => {\n        const db = client.db(dbName, dbOptions);\n        if (endCursor && request.filter[1]) {\n          await persistState({\n            db,\n            endCursor,\n            session,\n            filter: request.filter[1],\n            indexerId,\n          });\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"message:finalize\", async ({ message }) => {\n      const { cursor } = message;\n\n      if (!cursor) {\n        throw new MongoStorageError(\"finalized cursor is undefined\");\n      }\n\n      await withTransaction(client, async (session) => {\n        const db = client.db(dbName, dbOptions);\n        await finalize(db, session, cursor, collections);\n\n        if (enablePersistence) {\n          await finalizeState({ db, session, cursor, indexerId });\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"message:invalidate\", async ({ message }) => {\n      const { cursor } = message;\n\n      if (!cursor) {\n        throw new MongoStorageError(\"invalidate cursor is undefined\");\n      }\n\n      await withTransaction(client, async (session) => {\n        const db = client.db(dbName, dbOptions);\n        await invalidate(db, session, cursor, collections);\n\n        if (enablePersistence) {\n          await invalidateState({ db, session, cursor, indexerId });\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"handler:middleware\", async ({ use }) => {\n      use(async (context, next) => {\n        const { endCursor, finality, cursor } = context as {\n          cursor: Cursor;\n          endCursor: Cursor;\n          finality: DataFinality;\n        };\n\n        if (!endCursor) {\n          throw new MongoStorageError(\"end cursor is undefined\");\n        }\n\n        await withTransaction(client, async (session) => {\n          const db = client.db(dbName, dbOptions);\n          context[MONGO_PROPERTY] = new MongoStorage(db, session, endCursor);\n\n          if (prevFinality === \"pending\") {\n            // invalidate if previous block's finality was \"pending\"\n            await invalidate(db, session, cursor, collections);\n          }\n\n          await next();\n\n          delete context[MONGO_PROPERTY];\n\n          if (enablePersistence && finality !== \"pending\") {\n            await persistState({\n              db,\n              endCursor,\n              session,\n              indexerId,\n            });\n          }\n\n          prevFinality = finality;\n        });\n      });\n    });\n  });\n}\n"],"names":["session"],"mappings":"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"}