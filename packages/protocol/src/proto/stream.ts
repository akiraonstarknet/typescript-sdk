// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               unknown
// source: stream.proto

/* eslint-disable */
import { type CallContext, type CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal";
import { Cursor, StatusRequest, StatusResponse } from "./common";

export const protobufPackage = "dna.v2.stream";

/** Apibara DNA server V2 */

/** Data finality. */
export enum DataFinality {
  DATA_FINALITY_UNKNOWN = 0,
  /** DATA_FINALITY_PENDING - Data was received, but is not part of the canonical chain yet. */
  DATA_FINALITY_PENDING = 1,
  /** DATA_FINALITY_ACCEPTED - Data is now part of the canonical chain, but could still be invalidated. */
  DATA_FINALITY_ACCEPTED = 2,
  /** DATA_FINALITY_FINALIZED - Data is finalized and cannot be invalidated. */
  DATA_FINALITY_FINALIZED = 3,
  UNRECOGNIZED = -1,
}

export function dataFinalityFromJSON(object: any): DataFinality {
  switch (object) {
    case 0:
    case "DATA_FINALITY_UNKNOWN":
      return DataFinality.DATA_FINALITY_UNKNOWN;
    case 1:
    case "DATA_FINALITY_PENDING":
      return DataFinality.DATA_FINALITY_PENDING;
    case 2:
    case "DATA_FINALITY_ACCEPTED":
      return DataFinality.DATA_FINALITY_ACCEPTED;
    case 3:
    case "DATA_FINALITY_FINALIZED":
      return DataFinality.DATA_FINALITY_FINALIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataFinality.UNRECOGNIZED;
  }
}

export function dataFinalityToJSON(object: DataFinality): string {
  switch (object) {
    case DataFinality.DATA_FINALITY_UNKNOWN:
      return "DATA_FINALITY_UNKNOWN";
    case DataFinality.DATA_FINALITY_PENDING:
      return "DATA_FINALITY_PENDING";
    case DataFinality.DATA_FINALITY_ACCEPTED:
      return "DATA_FINALITY_ACCEPTED";
    case DataFinality.DATA_FINALITY_FINALIZED:
      return "DATA_FINALITY_FINALIZED";
    case DataFinality.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request data to be streamed. */
export interface StreamDataRequest {
  /** Cursor to start streaming from. */
  startingCursor:
    | Cursor
    | undefined;
  /**
   * Return data with the specified finality.
   * If not specified, defaults to `DATA_FINALITY_ACCEPTED`.
   */
  finality?:
    | DataFinality
    | undefined;
  /** Filters used to generate data. */
  filter: Uint8Array[];
}

/** Contains a piece of streamed data. */
export interface StreamDataResponse {
  message?:
    | { $case: "data"; data: Data }
    | { $case: "invalidate"; invalidate: Invalidate }
    | { $case: "heartbeat"; heartbeat: Heartbeat }
    | { $case: "systemMessage"; systemMessage: SystemMessage }
    | undefined;
}

/** Invalidate data after the given cursor. */
export interface Invalidate {
  /** The cursor of the message before the now invalid data. */
  cursor: Cursor | undefined;
}

/**
 * A single block of data.
 *
 * If the request specified multiple filters, the `data` field will contain the
 * data for each filter in the same order as the filters were specified in the
 * request.
 * If no data is available for a filter, the corresponding data field will be
 * empty.
 */
export interface Data {
  /** Cursor that generated this block of data. */
  cursor:
    | Cursor
    | undefined;
  /** Block cursor. Use this cursor to resume the stream. */
  endCursor:
    | Cursor
    | undefined;
  /** The finality status of the block. */
  finality: DataFinality;
  /** The block data. */
  data: Uint8Array[];
}

/** Sent to clients to check if stream is still connected. */
export interface Heartbeat {
}

/** Message from the server to the client. */
export interface SystemMessage {
  output?: { $case: "stdout"; stdout: string } | { $case: "stderr"; stderr: string } | undefined;
}

function createBaseStreamDataRequest(): StreamDataRequest {
  return { startingCursor: undefined, finality: undefined, filter: [] };
}

export const StreamDataRequest = {
  encode(message: StreamDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startingCursor !== undefined) {
      Cursor.encode(message.startingCursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.finality !== undefined) {
      writer.uint32(16).int32(message.finality);
    }
    for (const v of message.filter) {
      writer.uint32(26).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startingCursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.finality = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDataRequest {
    return {
      startingCursor: isSet(object.startingCursor) ? Cursor.fromJSON(object.startingCursor) : undefined,
      finality: isSet(object.finality) ? dataFinalityFromJSON(object.finality) : undefined,
      filter: globalThis.Array.isArray(object?.filter) ? object.filter.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: StreamDataRequest): unknown {
    const obj: any = {};
    if (message.startingCursor !== undefined) {
      obj.startingCursor = Cursor.toJSON(message.startingCursor);
    }
    if (message.finality !== undefined) {
      obj.finality = dataFinalityToJSON(message.finality);
    }
    if (message.filter?.length) {
      obj.filter = message.filter.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDataRequest>): StreamDataRequest {
    return StreamDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDataRequest>): StreamDataRequest {
    const message = createBaseStreamDataRequest();
    message.startingCursor = (object.startingCursor !== undefined && object.startingCursor !== null)
      ? Cursor.fromPartial(object.startingCursor)
      : undefined;
    message.finality = object.finality ?? undefined;
    message.filter = object.filter?.map((e) => e) || [];
    return message;
  },
};

function createBaseStreamDataResponse(): StreamDataResponse {
  return { message: undefined };
}

export const StreamDataResponse = {
  encode(message: StreamDataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.message?.$case) {
      case "data":
        Data.encode(message.message.data, writer.uint32(10).fork()).ldelim();
        break;
      case "invalidate":
        Invalidate.encode(message.message.invalidate, writer.uint32(18).fork()).ldelim();
        break;
      case "heartbeat":
        Heartbeat.encode(message.message.heartbeat, writer.uint32(26).fork()).ldelim();
        break;
      case "systemMessage":
        SystemMessage.encode(message.message.systemMessage, writer.uint32(34).fork()).ldelim();
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamDataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "data", data: Data.decode(reader, reader.uint32()) };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = { $case: "invalidate", invalidate: Invalidate.decode(reader, reader.uint32()) };
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = { $case: "heartbeat", heartbeat: Heartbeat.decode(reader, reader.uint32()) };
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = { $case: "systemMessage", systemMessage: SystemMessage.decode(reader, reader.uint32()) };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamDataResponse {
    return {
      message: isSet(object.data)
        ? { $case: "data", data: Data.fromJSON(object.data) }
        : isSet(object.invalidate)
        ? { $case: "invalidate", invalidate: Invalidate.fromJSON(object.invalidate) }
        : isSet(object.heartbeat)
        ? { $case: "heartbeat", heartbeat: Heartbeat.fromJSON(object.heartbeat) }
        : isSet(object.systemMessage)
        ? { $case: "systemMessage", systemMessage: SystemMessage.fromJSON(object.systemMessage) }
        : undefined,
    };
  },

  toJSON(message: StreamDataResponse): unknown {
    const obj: any = {};
    if (message.message?.$case === "data") {
      obj.data = Data.toJSON(message.message.data);
    }
    if (message.message?.$case === "invalidate") {
      obj.invalidate = Invalidate.toJSON(message.message.invalidate);
    }
    if (message.message?.$case === "heartbeat") {
      obj.heartbeat = Heartbeat.toJSON(message.message.heartbeat);
    }
    if (message.message?.$case === "systemMessage") {
      obj.systemMessage = SystemMessage.toJSON(message.message.systemMessage);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamDataResponse>): StreamDataResponse {
    return StreamDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamDataResponse>): StreamDataResponse {
    const message = createBaseStreamDataResponse();
    if (object.message?.$case === "data" && object.message?.data !== undefined && object.message?.data !== null) {
      message.message = { $case: "data", data: Data.fromPartial(object.message.data) };
    }
    if (
      object.message?.$case === "invalidate" &&
      object.message?.invalidate !== undefined &&
      object.message?.invalidate !== null
    ) {
      message.message = { $case: "invalidate", invalidate: Invalidate.fromPartial(object.message.invalidate) };
    }
    if (
      object.message?.$case === "heartbeat" &&
      object.message?.heartbeat !== undefined &&
      object.message?.heartbeat !== null
    ) {
      message.message = { $case: "heartbeat", heartbeat: Heartbeat.fromPartial(object.message.heartbeat) };
    }
    if (
      object.message?.$case === "systemMessage" &&
      object.message?.systemMessage !== undefined &&
      object.message?.systemMessage !== null
    ) {
      message.message = {
        $case: "systemMessage",
        systemMessage: SystemMessage.fromPartial(object.message.systemMessage),
      };
    }
    return message;
  },
};

function createBaseInvalidate(): Invalidate {
  return { cursor: undefined };
}

export const Invalidate = {
  encode(message: Invalidate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Invalidate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Invalidate {
    return { cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined };
  },

  toJSON(message: Invalidate): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<Invalidate>): Invalidate {
    return Invalidate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Invalidate>): Invalidate {
    const message = createBaseInvalidate();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseData(): Data {
  return { cursor: undefined, endCursor: undefined, finality: 0, data: [] };
}

export const Data = {
  encode(message: Data, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.endCursor !== undefined) {
      Cursor.encode(message.endCursor, writer.uint32(18).fork()).ldelim();
    }
    if (message.finality !== 0) {
      writer.uint32(24).int32(message.finality);
    }
    for (const v of message.data) {
      writer.uint32(34).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Data {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endCursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.finality = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Data {
    return {
      cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined,
      endCursor: isSet(object.endCursor) ? Cursor.fromJSON(object.endCursor) : undefined,
      finality: isSet(object.finality) ? dataFinalityFromJSON(object.finality) : 0,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: Data): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    if (message.endCursor !== undefined) {
      obj.endCursor = Cursor.toJSON(message.endCursor);
    }
    if (message.finality !== 0) {
      obj.finality = dataFinalityToJSON(message.finality);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Data>): Data {
    return Data.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Data>): Data {
    const message = createBaseData();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    message.endCursor = (object.endCursor !== undefined && object.endCursor !== null)
      ? Cursor.fromPartial(object.endCursor)
      : undefined;
    message.finality = object.finality ?? 0;
    message.data = object.data?.map((e) => e) || [];
    return message;
  },
};

function createBaseHeartbeat(): Heartbeat {
  return {};
}

export const Heartbeat = {
  encode(_: Heartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Heartbeat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Heartbeat {
    return {};
  },

  toJSON(_: Heartbeat): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Heartbeat>): Heartbeat {
    return Heartbeat.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Heartbeat>): Heartbeat {
    const message = createBaseHeartbeat();
    return message;
  },
};

function createBaseSystemMessage(): SystemMessage {
  return { output: undefined };
}

export const SystemMessage = {
  encode(message: SystemMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    switch (message.output?.$case) {
      case "stdout":
        writer.uint32(10).string(message.output.stdout);
        break;
      case "stderr":
        writer.uint32(18).string(message.output.stderr);
        break;
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SystemMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.output = { $case: "stdout", stdout: reader.string() };
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output = { $case: "stderr", stderr: reader.string() };
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemMessage {
    return {
      output: isSet(object.stdout)
        ? { $case: "stdout", stdout: globalThis.String(object.stdout) }
        : isSet(object.stderr)
        ? { $case: "stderr", stderr: globalThis.String(object.stderr) }
        : undefined,
    };
  },

  toJSON(message: SystemMessage): unknown {
    const obj: any = {};
    if (message.output?.$case === "stdout") {
      obj.stdout = message.output.stdout;
    }
    if (message.output?.$case === "stderr") {
      obj.stderr = message.output.stderr;
    }
    return obj;
  },

  create(base?: DeepPartial<SystemMessage>): SystemMessage {
    return SystemMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SystemMessage>): SystemMessage {
    const message = createBaseSystemMessage();
    if (object.output?.$case === "stdout" && object.output?.stdout !== undefined && object.output?.stdout !== null) {
      message.output = { $case: "stdout", stdout: object.output.stdout };
    }
    if (object.output?.$case === "stderr" && object.output?.stderr !== undefined && object.output?.stderr !== null) {
      message.output = { $case: "stderr", stderr: object.output.stderr };
    }
    return message;
  },
};

export type DnaStreamDefinition = typeof DnaStreamDefinition;
export const DnaStreamDefinition = {
  name: "DnaStream",
  fullName: "dna.v2.stream.DnaStream",
  methods: {
    /** Stream data from the server. */
    streamData: {
      name: "StreamData",
      requestType: StreamDataRequest,
      requestStream: false,
      responseType: StreamDataResponse,
      responseStream: true,
      options: {},
    },
    /** Get DNA server status. */
    status: {
      name: "Status",
      requestType: StatusRequest,
      requestStream: false,
      responseType: StatusResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface DnaStreamServiceImplementation<CallContextExt = {}> {
  /** Stream data from the server. */
  streamData(
    request: StreamDataRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<StreamDataResponse>>;
  /** Get DNA server status. */
  status(request: StatusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<StatusResponse>>;
}

export interface DnaStreamClient<CallOptionsExt = {}> {
  /** Stream data from the server. */
  streamData(
    request: DeepPartial<StreamDataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<StreamDataResponse>;
  /** Get DNA server status. */
  status(request: DeepPartial<StatusRequest>, options?: CallOptions & CallOptionsExt): Promise<StatusResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };
