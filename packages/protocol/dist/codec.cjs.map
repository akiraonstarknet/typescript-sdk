{"version":3,"file":"codec.cjs","sources":["../src/codec.ts"],"sourcesContent":["/*\n\n   █████████               █████                  \n  ███░░░░░███             ░░███                   \n ███     ░░░   ██████   ███████   ██████   ██████ \n░███          ███░░███ ███░░███  ███░░███ ███░░███\n░███         ░███ ░███░███ ░███ ░███████ ░███ ░░░ \n░░███     ███░███ ░███░███ ░███ ░███░░░  ░███  ███\n ░░█████████ ░░██████ ░░████████░░██████ ░░██████ \n  ░░░░░░░░░   ░░░░░░   ░░░░░░░░  ░░░░░░   ░░░░░░  \n                                                  \n*/\n\n/** Codec to encode and decode protobuf messages */\nexport type Codec<TApp = unknown, TProto = unknown> = {\n  encode(app: TApp): TProto;\n  decode(proto: TProto): TApp;\n};\n\n/* Helper to get the high-level type of a codec */\nexport type CodecType<C extends Codec> = ReturnType<C[\"decode\"]>;\n\n/* Helper to get the protobuf type of a codec */\nexport type CodecProto<C extends Codec> = ReturnType<C[\"encode\"]>;\n\n/*\n \n ██████   ██████                                                     \n░░██████ ██████                                                      \n ░███░█████░███   ██████   █████   █████   ██████    ███████  ██████ \n ░███░░███ ░███  ███░░███ ███░░   ███░░   ░░░░░███  ███░░███ ███░░███\n ░███ ░░░  ░███ ░███████ ░░█████ ░░█████   ███████ ░███ ░███░███████ \n ░███      ░███ ░███░░░   ░░░░███ ░░░░███ ███░░███ ░███ ░███░███░░░  \n █████     █████░░██████  ██████  ██████ ░░████████░░███████░░██████ \n░░░░░     ░░░░░  ░░░░░░  ░░░░░░  ░░░░░░   ░░░░░░░░  ░░░░░███ ░░░░░░  \n                                                    ███ ░███         \n                                                   ░░██████          \n                                                    ░░░░░░                                                                             \n*/\n\nexport type Evaluate<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;\n\ntype TPropertyKey = string | symbol;\n// Message properties as codec.\ntype TProperties = Record<TPropertyKey, Codec>;\n\n// Optional properties in an object.\n// Properties are optional when they have the `undefined` type.\ntype OptionalPropertyKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never;\n}[keyof T];\n\n// Properties that are not optional are required.\ntype RequiredPropertyKeys<T> = keyof Omit<T, OptionalPropertyKeys<T>>;\n\n// Helper to get the app type of a message codec.\ntype _MessageCodecType<T extends TProperties> = {\n  [K in keyof T]: CodecType<T[K]>;\n};\n\n// Helper to get the protobuf type of a message codec.\ntype _MessageCodecProto<T extends TProperties> = {\n  [K in keyof T]: CodecProto<T[K]>;\n};\n\n// Adjust the app type of the codec so that optional properties are optional.\ntype MessageCodecType<T extends TProperties> =\n  _MessageCodecType<T> extends infer R\n    ? Evaluate<Partial<R> & Required<Pick<R, RequiredPropertyKeys<R>>>>\n    : never;\n\n// Adjust the protobuf type of the codec so that optional properties are optional.\ntype MessageCodecProto<T extends TProperties> =\n  _MessageCodecProto<T> extends infer R\n    ? Evaluate<Partial<R> & Required<Pick<R, RequiredPropertyKeys<R>>>>\n    : never;\n\nexport type MessageCodec<T extends TProperties = TProperties> = Codec<\n  MessageCodecType<T>,\n  MessageCodecProto<T>\n>;\n\nexport function MessageCodec<T extends TProperties>(\n  schema: T,\n): MessageCodec<T> {\n  return {\n    encode(app) {\n      return new Proxy(app, {\n        get(target, property) {\n          if (!Object.hasOwn(target, property)) {\n            return Reflect.get(target, property);\n          }\n\n          const v = Reflect.get(target, property);\n          return schema[property].encode(v);\n        },\n      });\n    },\n    decode(proto) {\n      return new Proxy(proto, {\n        get(target, property) {\n          if (!Object.hasOwn(target, property)) {\n            return Reflect.get(target, property);\n          }\n\n          const v = Reflect.get(target, property);\n          return schema[property].decode(v);\n        },\n      });\n    },\n  };\n}\n\n/*\n   █████████                                           \n  ███░░░░░███                                          \n ░███    ░███  ████████  ████████   ██████   █████ ████\n ░███████████ ░░███░░███░░███░░███ ░░░░░███ ░░███ ░███ \n ░███░░░░░███  ░███ ░░░  ░███ ░░░   ███████  ░███ ░███ \n ░███    ░███  ░███      ░███      ███░░███  ░███ ░███ \n █████   █████ █████     █████    ░░████████ ░░███████ \n░░░░░   ░░░░░ ░░░░░     ░░░░░      ░░░░░░░░   ░░░░░███ \n                                              ███ ░███ \n                                             ░░██████  \n                                              ░░░░░░   \n                                                                    \n*/\n\nexport type ArrayCodec<T extends Codec> = T extends Codec<\n  infer TApp,\n  infer TProto\n>\n  ? Codec<readonly TApp[], readonly TProto[] | undefined>\n  : never;\n\nexport function ArrayCodec<T extends Codec<TApp, TProto>, TApp, TProto>(\n  t: T,\n): ArrayCodec<T> {\n  return {\n    encode(app) {\n      return app.map(t.encode) as readonly TProto[];\n    },\n    decode(proto) {\n      if (proto === undefined) return [];\n      return proto.map(t.decode) as readonly TApp[];\n    },\n  } as ArrayCodec<T>;\n}\n\n/*\n ██████   ██████             █████              █████     ████             █████████               █████                  \n░░██████ ██████             ░░███              ░░███     ░░███            ███░░░░░███             ░░███                   \n ░███░█████░███  █████ ████ ███████    ██████   ░███████  ░███   ██████  ███     ░░░   ██████   ███████   ██████   ██████ \n ░███░░███ ░███ ░░███ ░███ ░░░███░    ░░░░░███  ░███░░███ ░███  ███░░███░███          ███░░███ ███░░███  ███░░███ ███░░███\n ░███ ░░░  ░███  ░███ ░███   ░███      ███████  ░███ ░███ ░███ ░███████ ░███         ░███ ░███░███ ░███ ░███████ ░███ ░░░ \n ░███      ░███  ░███ ░███   ░███ ███ ███░░███  ░███ ░███ ░███ ░███░░░  ░░███     ███░███ ░███░███ ░███ ░███░░░  ░███  ███\n █████     █████ ░░████████  ░░█████ ░░████████ ████████  █████░░██████  ░░█████████ ░░██████ ░░████████░░██████ ░░██████ \n░░░░░     ░░░░░   ░░░░░░░░    ░░░░░   ░░░░░░░░ ░░░░░░░░  ░░░░░  ░░░░░░    ░░░░░░░░░   ░░░░░░   ░░░░░░░░  ░░░░░░   ░░░░░░  \n*/\nexport type MutableArrayCodec<\n  T extends Codec<TApp, TProto>,\n  TApp,\n  TProto,\n> = T extends Codec<infer TApp, infer TProto> ? Codec<TApp[], TProto[]> : never;\n\nexport function MutableArrayCodec<T extends Codec<TApp, TProto>, TApp, TProto>(\n  t: T,\n): MutableArrayCodec<T, TApp, TProto> {\n  return {\n    encode(app) {\n      return app.map(t.encode) as TProto[];\n    },\n    decode(proto) {\n      if (proto === undefined) return [];\n      return proto.map(t.decode) as TApp[];\n    },\n  } as MutableArrayCodec<T, TApp, TProto>;\n}\n\n/*\n    ███████               █████     ███                                ████ \n  ███░░░░░███            ░░███     ░░░                                ░░███ \n ███     ░░███ ████████  ███████   ████   ██████  ████████    ██████   ░███ \n░███      ░███░░███░░███░░░███░   ░░███  ███░░███░░███░░███  ░░░░░███  ░███ \n░███      ░███ ░███ ░███  ░███     ░███ ░███ ░███ ░███ ░███   ███████  ░███ \n░░███     ███  ░███ ░███  ░███ ███ ░███ ░███ ░███ ░███ ░███  ███░░███  ░███ \n ░░░███████░   ░███████   ░░█████  █████░░██████  ████ █████░░████████ █████\n   ░░░░░░░     ░███░░░     ░░░░░  ░░░░░  ░░░░░░  ░░░░ ░░░░░  ░░░░░░░░ ░░░░░ \n               ░███                                                         \n               █████                                                        \n              ░░░░░                                                                                                                                                  \n*/\n\nexport type OptionalCodec<T extends Codec> = T extends Codec<\n  infer TApp,\n  infer TProto\n>\n  ? Codec<TApp | undefined, TProto | undefined>\n  : never;\n\nexport function OptionalCodec<T extends Codec>(t: T): OptionalCodec<T> {\n  return {\n    encode(app) {\n      if (app === undefined) return undefined;\n      return t.encode(app);\n    },\n    decode(proto) {\n      if (proto === undefined) return undefined;\n      return t.decode(proto);\n    },\n  } as OptionalCodec<T>;\n}\n\n/*\n ███████████                                  ███                         █████\n░░███░░░░░███                                ░░░                         ░░███ \n ░███    ░███   ██████   ████████ █████ ████ ████  ████████   ██████   ███████ \n ░██████████   ███░░███ ███░░███ ░░███ ░███ ░░███ ░░███░░███ ███░░███ ███░░███ \n ░███░░░░░███ ░███████ ░███ ░███  ░███ ░███  ░███  ░███ ░░░ ░███████ ░███ ░███ \n ░███    ░███ ░███░░░  ░███ ░███  ░███ ░███  ░███  ░███     ░███░░░  ░███ ░███ \n █████   █████░░██████ ░░███████  ░░████████ █████ █████    ░░██████ ░░████████\n░░░░░   ░░░░░  ░░░░░░   ░░░░░███   ░░░░░░░░ ░░░░░ ░░░░░      ░░░░░░   ░░░░░░░░ \n                            ░███                                               \n                            █████                                              \n                           ░░░░░                                                                                                                                                           \n*/\n\nexport type RequiredCodec<T extends Codec> = T extends Codec<\n  infer TApp,\n  infer TProto\n>\n  ? TApp extends undefined\n    ? never\n    : Codec<TApp, TProto | undefined>\n  : never;\n\nexport function RequiredCodec<T extends Codec>(t: T): RequiredCodec<T> {\n  return {\n    encode(app) {\n      if (app === undefined) throw new Error(\"Value is required but undefined\");\n      return t.encode(app);\n    },\n    decode(proto) {\n      if (proto === undefined)\n        throw new Error(\"Value is required but undefined\");\n      return t.decode(proto);\n    },\n  } as RequiredCodec<T>;\n}\n\n/*\n ██████   █████            ████  ████     ███████             \n░░██████ ░░███            ░░███ ░░███   ███░░░░░███           \n ░███░███ ░███  █████ ████ ░███  ░███  ███     ░░███ ████████ \n ░███░░███░███ ░░███ ░███  ░███  ░███ ░███      ░███░░███░░███\n ░███ ░░██████  ░███ ░███  ░███  ░███ ░███      ░███ ░███ ░░░ \n ░███  ░░█████  ░███ ░███  ░███  ░███ ░░███     ███  ░███     \n █████  ░░█████ ░░████████ █████ █████ ░░░███████░   █████    \n░░░░░    ░░░░░   ░░░░░░░░ ░░░░░ ░░░░░    ░░░░░░░    ░░░░░     \n*/\n\nexport type NullOrCodec<T extends Codec> = T extends Codec<\n  infer TApp,\n  infer TProto\n>\n  ? Codec<TApp | null, TProto | null>\n  : never;\n\nexport function NullOrCodec<T extends Codec>(t: T): NullOrCodec<T> {\n  return {\n    encode(app) {\n      if (app === null) return null;\n      return t.encode(app);\n    },\n    decode(proto) {\n      if (proto === null) return null;\n      return t.decode(proto);\n    },\n  } as NullOrCodec<T>;\n}\n\n/*\n\n ███████████   ███           █████             █████   \n░░███░░░░░███ ░░░           ░░███             ░░███    \n ░███    ░███ ████   ███████ ░███  ████████   ███████  \n ░██████████ ░░███  ███░░███ ░███ ░░███░░███ ░░░███░   \n ░███░░░░░███ ░███ ░███ ░███ ░███  ░███ ░███   ░███    \n ░███    ░███ ░███ ░███ ░███ ░███  ░███ ░███   ░███ ███\n ███████████  █████░░███████ █████ ████ █████  ░░█████ \n░░░░░░░░░░░  ░░░░░  ░░░░░███░░░░░ ░░░░ ░░░░░    ░░░░░  \n                    ███ ░███                           \n                   ░░██████                            \n                    ░░░░░░                                                                             \n*/\n\nexport type BigIntCodec = CodecType<typeof BigIntCodec>;\n\nexport const BigIntCodec: Codec<bigint, bigint> = {\n  encode(app) {\n    return app;\n  },\n  decode(proto) {\n    return proto;\n  },\n};\n\n/*\n\n ██████   █████                            █████                       \n░░██████ ░░███                            ░░███                        \n ░███░███ ░███  █████ ████ █████████████   ░███████   ██████  ████████ \n ░███░░███░███ ░░███ ░███ ░░███░░███░░███  ░███░░███ ███░░███░░███░░███\n ░███ ░░██████  ░███ ░███  ░███ ░███ ░███  ░███ ░███░███████  ░███ ░░░ \n ░███  ░░█████  ░███ ░███  ░███ ░███ ░███  ░███ ░███░███░░░   ░███     \n █████  ░░█████ ░░████████ █████░███ █████ ████████ ░░██████  █████    \n░░░░░    ░░░░░   ░░░░░░░░ ░░░░░ ░░░ ░░░░░ ░░░░░░░░   ░░░░░░  ░░░░░     \n                                                                                  \n*/\n\nexport type NumberCodec = CodecType<typeof NumberCodec>;\n\nexport const NumberCodec: Codec<number, number> = {\n  encode(app) {\n    return app;\n  },\n  decode(proto) {\n    return proto;\n  },\n};\n\n/*\n █████  █████  ███              █████     ████████     █████████                                           \n░░███  ░░███  ░░░              ░░███     ███░░░░███   ███░░░░░███                                          \n ░███   ░███  ████  ████████   ███████  ░███   ░███  ░███    ░███  ████████  ████████   ██████   █████ ████\n ░███   ░███ ░░███ ░░███░░███ ░░░███░   ░░████████   ░███████████ ░░███░░███░░███░░███ ░░░░░███ ░░███ ░███ \n ░███   ░███  ░███  ░███ ░███   ░███     ███░░░░███  ░███░░░░░███  ░███ ░░░  ░███ ░░░   ███████  ░███ ░███ \n ░███   ░███  ░███  ░███ ░███   ░███ ███░███   ░███  ░███    ░███  ░███      ░███      ███░░███  ░███ ░███ \n ░░████████   █████ ████ █████  ░░█████ ░░████████   █████   █████ █████     █████    ░░████████ ░░███████ \n  ░░░░░░░░   ░░░░░ ░░░░ ░░░░░    ░░░░░   ░░░░░░░░   ░░░░░   ░░░░░ ░░░░░     ░░░░░      ░░░░░░░░   ░░░░░███ \n                                                                                                  ███ ░███ \n                                                                                                 ░░██████  \n                                                                                                  ░░░░░░   \n*/\n\nexport type Uint8ArrayCodec = CodecType<typeof Uint8ArrayCodec>;\n\nexport const Uint8ArrayCodec: Codec<Uint8Array, Uint8Array> = {\n  encode(app) {\n    return app;\n  },\n  decode(proto) {\n    return proto;\n  },\n};\n\n/*\n\n ██████████              █████            \n░░███░░░░███            ░░███             \n ░███   ░░███  ██████   ███████    ██████ \n ░███    ░███ ░░░░░███ ░░░███░    ███░░███\n ░███    ░███  ███████   ░███    ░███████ \n ░███    ███  ███░░███   ░███ ███░███░░░  \n ██████████  ░░████████  ░░█████ ░░██████ \n░░░░░░░░░░    ░░░░░░░░    ░░░░░   ░░░░░░  \n                                          \n*/\n\nexport type DateCodec = CodecType<typeof DateCodec>;\n\nexport const DateCodec: Codec<Date, Date> = {\n  encode(app) {\n    return new Date(app);\n  },\n  decode(proto) {\n    return new Date(proto);\n  },\n};\n\n/*\n\n ███████████                    ████                               \n░░███░░░░░███                  ░░███                               \n ░███    ░███  ██████   ██████  ░███   ██████   ██████   ████████  \n ░██████████  ███░░███ ███░░███ ░███  ███░░███ ░░░░░███ ░░███░░███ \n ░███░░░░░███░███ ░███░███ ░███ ░███ ░███████   ███████  ░███ ░███ \n ░███    ░███░███ ░███░███ ░███ ░███ ░███░░░   ███░░███  ░███ ░███ \n ███████████ ░░██████ ░░██████  █████░░██████ ░░████████ ████ █████\n░░░░░░░░░░░   ░░░░░░   ░░░░░░  ░░░░░  ░░░░░░   ░░░░░░░░ ░░░░ ░░░░░ \n                                          \n*/\n\nexport type BooleanCodec = CodecType<typeof BooleanCodec>;\n\nexport const BooleanCodec: Codec<boolean, boolean> = {\n  encode(app) {\n    return app;\n  },\n  decode(proto) {\n    return proto;\n  },\n};\n\n/*\n\n  █████████   █████               ███                     \n ███░░░░░███ ░░███               ░░░                      \n░███    ░░░  ███████   ████████  ████  ████████    ███████\n░░█████████ ░░░███░   ░░███░░███░░███ ░░███░░███  ███░░███\n ░░░░░░░░███  ░███     ░███ ░░░  ░███  ░███ ░███ ░███ ░███\n ███    ░███  ░███ ███ ░███      ░███  ░███ ░███ ░███ ░███\n░░█████████   ░░█████  █████     █████ ████ █████░░███████\n ░░░░░░░░░     ░░░░░  ░░░░░     ░░░░░ ░░░░ ░░░░░  ░░░░░███\n                                                  ███ ░███\n                                                 ░░██████ \n                                                  ░░░░░░  \n*/\n\nexport type StringCodec = CodecType<typeof StringCodec>;\n\nexport const StringCodec: Codec<string, string> = {\n  encode(app) {\n    return app;\n  },\n  decode(proto) {\n    return proto;\n  },\n};\n\n/*\n\n █████  █████                █████             ██████   ███                          █████\n░░███  ░░███                ░░███             ███░░███ ░░░                          ░░███ \n ░███   ░███  ████████    ███████   ██████   ░███ ░░░  ████  ████████    ██████   ███████ \n ░███   ░███ ░░███░░███  ███░░███  ███░░███ ███████   ░░███ ░░███░░███  ███░░███ ███░░███ \n ░███   ░███  ░███ ░███ ░███ ░███ ░███████ ░░░███░     ░███  ░███ ░███ ░███████ ░███ ░███ \n ░███   ░███  ░███ ░███ ░███ ░███ ░███░░░    ░███      ░███  ░███ ░███ ░███░░░  ░███ ░███ \n ░░████████   ████ █████░░████████░░██████   █████     █████ ████ █████░░██████ ░░████████\n  ░░░░░░░░   ░░░░ ░░░░░  ░░░░░░░░  ░░░░░░   ░░░░░     ░░░░░ ░░░░ ░░░░░  ░░░░░░   ░░░░░░░░ \n                                          \n*/\n\nexport type UndefinedCodec = CodecType<typeof UndefinedCodec>;\n\nexport const UndefinedCodec: Codec<undefined, undefined> = {\n  encode(app) {\n    return undefined;\n  },\n  decode(proto) {\n    return undefined;\n  },\n};\n\n/*\n █████        ███   █████                                 ████ \n░░███        ░░░   ░░███                                 ░░███ \n ░███        ████  ███████    ██████  ████████   ██████   ░███ \n ░███       ░░███ ░░░███░    ███░░███░░███░░███ ░░░░░███  ░███ \n ░███        ░███   ░███    ░███████  ░███ ░░░   ███████  ░███ \n ░███      █ ░███   ░███ ███░███░░░   ░███      ███░░███  ░███ \n ███████████ █████  ░░█████ ░░██████  █████    ░░████████ █████\n░░░░░░░░░░░ ░░░░░    ░░░░░   ░░░░░░  ░░░░░      ░░░░░░░░ ░░░░░ \n                                                               \n*/\n\ntype Literal = string | number | boolean | null | undefined;\n\nexport type LiteralCodec<T extends Codec, L extends Literal> = T extends Codec<\n  infer TApp,\n  infer TProto\n>\n  ? Codec<TApp, TProto>\n  : never;\n\nexport const LiteralCodec = <const L extends Literal>(\n  value: L,\n): LiteralCodec<Codec<L, L>, L> => {\n  return {\n    encode(app) {\n      if (app !== value) {\n        throw new Error(`Expected ${String(value)}, got ${String(app)}`);\n      }\n      return app;\n    },\n    decode(proto) {\n      if (proto !== value) {\n        throw new Error(`Expected ${String(value)}, got ${String(proto)}`);\n      }\n      return proto;\n    },\n  } as LiteralCodec<Codec<L, L>, L>;\n};\n\n/*\n █████        ███   █████                                 ████  █████  █████             ███                     \n░░███        ░░░   ░░███                                 ░░███ ░░███  ░░███             ░░░                      \n ░███        ████  ███████    ██████  ████████   ██████   ░███  ░███   ░███  ████████   ████   ██████  ████████  \n ░███       ░░███ ░░░███░    ███░░███░░███░░███ ░░░░░███  ░███  ░███   ░███ ░░███░░███ ░░███  ███░░███░░███░░███ \n ░███        ░███   ░███    ░███████  ░███ ░░░   ███████  ░███  ░███   ░███  ░███ ░███  ░███ ░███ ░███ ░███ ░███ \n ░███      █ ░███   ░███ ███░███░░░   ░███      ███░░███  ░███  ░███   ░███  ░███ ░███  ░███ ░███ ░███ ░███ ░███ \n ███████████ █████  ░░█████ ░░██████  █████    ░░████████ █████ ░░████████   ████ █████ █████░░██████  ████ █████\n░░░░░░░░░░░ ░░░░░    ░░░░░   ░░░░░░  ░░░░░      ░░░░░░░░ ░░░░░   ░░░░░░░░   ░░░░ ░░░░░ ░░░░░  ░░░░░░  ░░░░ ░░░░░ \n*/\n\nexport type LiteralUnionCodec<\n  T extends Codec,\n  L extends readonly Literal[],\n> = T extends Codec<infer TApp, infer TProto> ? Codec<TApp, TProto> : never;\n\nexport const LiteralUnionCodec = <const L extends readonly Literal[]>(\n  values: L,\n): LiteralUnionCodec<Codec<L[number], L[number]>, L> => {\n  return {\n    encode(app) {\n      if (!values.includes(app as L[number])) {\n        throw new Error(\n          `Expected one of [${values.join(\", \")}], got ${String(app)}`,\n        );\n      }\n      return app;\n    },\n    decode(proto) {\n      if (!values.includes(proto as L[number])) {\n        throw new Error(\n          `Expected one of [${values.join(\", \")}], got ${String(proto)}`,\n        );\n      }\n      return proto;\n    },\n  } as LiteralUnionCodec<Codec<L[number], L[number]>, L>;\n};\n\n/*\n █████   █████                      ███                        █████   \n░░███   ░░███                      ░░░                        ░░███    \n ░███    ░███   ██████   ████████  ████   ██████   ████████   ███████  \n ░███    ░███  ░░░░░███ ░░███░░███░░███  ░░░░░███ ░░███░░███ ░░░███░   \n ░░███   ███    ███████  ░███ ░░░  ░███   ███████  ░███ ░███   ░███    \n  ░░░█████░    ███░░███  ░███      ░███  ███░░███  ░███ ░███   ░███ ███\n    ░░███     ░░████████ █████     █████░░████████ ████ █████  ░░█████ \n     ░░░       ░░░░░░░░ ░░░░░     ░░░░░  ░░░░░░░░ ░░░░ ░░░░░    ░░░░░  \n*/\n\n// Maps variant keys to their corresponding decoded types, adding a tag field\n// For example: { _tag: \"declareV1\", declareV1: { data: string } }\n// if the variant is undefined type, it will be just the tag - { _tag: \"heartbeat\" }\ntype AppVariantMap<TTag extends TPropertyKey, TVariants extends TProperties> = {\n  [K in keyof TVariants]: {\n    [P in TTag]: K;\n  } & (CodecType<TVariants[K]> extends UndefinedCodec\n    ? // biome-ignore lint/complexity/noBannedTypes: had to return empty object to satisfy type\n      {}\n    : { [P in K & TPropertyKey]: CodecType<TVariants[K]> });\n};\ntype VariantCodecType<\n  TTag extends TPropertyKey,\n  TVariants extends TProperties,\n> = AppVariantMap<TTag, TVariants>[keyof TVariants];\n\n// Maps variant keys to their corresponding encoded types, adding a discriminator field\n// For example: { $case: \"declareV1\", declareV1: { data: string } }\ntype ProtoVariantMap<\n  TDiscriminator extends TPropertyKey,\n  TVariants extends TProperties,\n> = {\n  [K in keyof TVariants]: {\n    [P in TDiscriminator]: K;\n  } & {\n    [P in K & TPropertyKey]: CodecProto<TVariants[K]>;\n  };\n};\n\ntype VariantCodecProto<\n  TDiscriminator extends TPropertyKey,\n  TVariants extends TProperties,\n> = ProtoVariantMap<TDiscriminator, TVariants>[keyof TVariants];\n\n// Type helper for VariantCodec that preserves the input/output types\nexport type VariantCodec<\n  T extends Codec,\n  TTag extends TPropertyKey,\n  TDiscriminator extends TPropertyKey,\n> = T extends Codec<infer TApp, infer TProto> ? Codec<TApp, TProto> : never;\n\nexport const VariantCodec = <\n  TTag extends TPropertyKey,\n  TDiscriminator extends TPropertyKey,\n  TVariants extends TProperties,\n  TCodec extends Codec<\n    VariantCodecType<TTag, TVariants>,\n    VariantCodecProto<TDiscriminator, TVariants>\n  >,\n>(options: {\n  tag: TTag;\n  discriminator: TDiscriminator;\n  variants: TVariants;\n}): VariantCodec<TCodec, TTag, TDiscriminator> => {\n  return {\n    encode(app) {\n      const tag = app[options.tag];\n      const codec = options.variants[tag];\n      if (!codec) {\n        throw new Error(`Unknown variant: ${String(tag)}`);\n      }\n\n      const variantData = app[tag as keyof typeof app];\n      const encodedData = codec.encode(variantData);\n\n      return {\n        [options.discriminator]: tag,\n        [tag]: encodedData,\n      };\n    },\n    decode(proto) {\n      const tag = proto[options.discriminator];\n      const codec = options.variants[tag];\n      if (!codec) {\n        throw new Error(`Unknown variant: ${String(tag)}`);\n      }\n\n      const variantData = proto[tag as keyof typeof proto];\n      const decodedData = codec.decode(variantData);\n\n      return {\n        [options.tag]: tag,\n        [tag]: decodedData,\n      };\n    },\n  } as VariantCodec<TCodec, TTag, TDiscriminator>;\n};\n\n/*\n    ███████                           ███████       ██████ \n  ███░░░░░███                       ███░░░░░███    ███░░███\n ███     ░░███ ████████    ██████  ███     ░░███  ░███ ░░░ \n░███      ░███░░███░░███  ███░░███░███      ░███ ███████   \n░███      ░███ ░███ ░███ ░███████ ░███      ░███░░░███░    \n░░███     ███  ░███ ░███ ░███░░░  ░░███     ███   ░███     \n ░░░███████░   ████ █████░░██████  ░░░███████░    █████    \n   ░░░░░░░    ░░░░ ░░░░░  ░░░░░░     ░░░░░░░     ░░░░░     \n                                                           \n*/\n\nexport type OneOfCodec<TVariants extends TProperties> = VariantCodec<\n  Codec<\n    VariantCodecType<\"_tag\", TVariants>,\n    VariantCodecProto<\"$case\", TVariants>\n  >,\n  \"_tag\",\n  \"$case\"\n>;\n\nexport function OneOfCodec<TVariants extends TProperties>(\n  variants: TVariants,\n): OneOfCodec<TVariants> {\n  return VariantCodec({\n    tag: \"_tag\",\n    discriminator: \"$case\",\n    variants,\n  });\n}\n"],"names":[],"mappings":"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"}