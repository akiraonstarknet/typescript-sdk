{"version":3,"file":"index.mjs","sources":["../../src/testing/client.ts","../../src/testing/mock.ts"],"sourcesContent":["import type { Client, ClientCallOptions, StreamDataOptions } from \"../client\";\nimport type { StatusRequest, StatusResponse } from \"../status\";\nimport type { StreamDataRequest, StreamDataResponse } from \"../stream\";\n\nexport class MockClient<TFilter, TBlock> implements Client<TFilter, TBlock> {\n  constructor(\n    private messageFactory: (\n      request: StreamDataRequest<TFilter>,\n      options?: StreamDataOptions,\n    ) => (StreamDataResponse<TBlock> | Error)[],\n  ) {}\n\n  async status(\n    request?: StatusRequest,\n    options?: ClientCallOptions,\n  ): Promise<StatusResponse> {\n    throw new Error(\"Client.status is not implemented for VcrClient\");\n  }\n\n  streamData(request: StreamDataRequest<TFilter>, options?: StreamDataOptions) {\n    const messages = this.messageFactory(request, options);\n\n    return new StreamDataIterable(messages);\n  }\n}\n\nexport class StreamDataIterable<TBlock> {\n  constructor(private messages: (StreamDataResponse<TBlock> | Error)[]) {}\n\n  [Symbol.asyncIterator](): AsyncIterator<StreamDataResponse<TBlock>> {\n    let index = 0;\n    const messages = this.messages;\n\n    return {\n      async next() {\n        if (index >= messages.length) {\n          return { done: true, value: undefined };\n        }\n\n        const message = messages[index++];\n        if (message instanceof Error) {\n          throw message;\n        }\n\n        return { done: false, value: message };\n      },\n    };\n  }\n}\n","import {\n  type Codec,\n  type CodecType,\n  MessageCodec,\n  OptionalCodec,\n  StringCodec,\n} from \"../codec\";\nimport { StreamConfig } from \"../config\";\nimport * as proto from \"../proto\";\nimport { StreamDataResponse } from \"../stream\";\n\nexport const MockFilter = MessageCodec({\n  filter: OptionalCodec(StringCodec),\n});\n\nexport type MockFilter = CodecType<typeof MockFilter>;\n\nexport const MockFilterFromBytes: Codec<MockFilter, Uint8Array> = {\n  decode(value) {\n    return proto.testing.MockFilter.decode(value);\n  },\n  encode(value) {\n    return proto.testing.MockFilter.encode(value).finish();\n  },\n};\n\nconst MockBlock = MessageCodec({\n  data: OptionalCodec(StringCodec),\n});\n\nexport type MockBlock = CodecType<typeof MockBlock>;\n\nexport const MockBlockFromBytes: Codec<MockBlock | null, Uint8Array> = {\n  decode(value) {\n    if (value.length === 0) {\n      return null;\n    }\n    return proto.testing.MockBlock.decode(value);\n  },\n  encode(value) {\n    if (value === null) {\n      return new Uint8Array();\n    }\n    return proto.testing.MockBlock.encode(value).finish();\n  },\n};\n\n/** For testing, simply concatenate the values of `.filter` */\nfunction mergeMockFilter(a: MockFilter, b: MockFilter): MockFilter {\n  let filter = \"\";\n  if (a.filter) {\n    filter += a.filter;\n  }\n  if (b.filter) {\n    filter += b.filter;\n  }\n  return { filter };\n}\n\nexport const MockStream = new StreamConfig(\n  MockFilterFromBytes,\n  MockBlockFromBytes,\n  mergeMockFilter,\n  \"mock\",\n);\n\nexport const MockStreamResponse = StreamDataResponse(MockBlockFromBytes);\n\nexport type MockStreamResponse = CodecType<typeof MockStreamResponse>;\n"],"names":["proto.testing.MockFilter","proto.testing.MockBlock"],"mappings":"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"}