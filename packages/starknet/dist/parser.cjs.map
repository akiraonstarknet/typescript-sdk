{"version":3,"file":"parser.cjs","sources":["../src/parser.ts"],"sourcesContent":["/*\n * Calldata combinatorial parsers.\n *\n * Based on the Ekubo's event parser.\n *\n * MIT License\n *\n * Copyright (c) 2023 Ekubo, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport type { FieldElement } from \"./common\";\n\nexport type Parser<TOut> = (\n  data: readonly FieldElement[],\n  offset: number,\n) => { out: TOut; offset: number };\n\nexport class ParseError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ParseError\";\n  }\n}\n\n// Primitive types.\n\nfunction assertInBounds(data: readonly FieldElement[], offset: number) {\n  if (offset >= data.length) {\n    throw new ParseError(\n      `Offset out of bounds. Data length ${data.length}, offset ${offset}`,\n    );\n  }\n}\n\nexport function parseBool(data: readonly FieldElement[], offset: number) {\n  assertInBounds(data, offset);\n  return { out: BigInt(data[offset]) > 0n, offset: offset + 1 };\n}\n\nexport function parseAsBigInt(data: readonly FieldElement[], offset: number) {\n  assertInBounds(data, offset);\n  return { out: BigInt(data[offset]), offset: offset + 1 };\n}\n\nexport const parseU8 = parseAsBigInt;\nexport const parseU16 = parseAsBigInt;\nexport const parseU32 = parseAsBigInt;\nexport const parseU64 = parseAsBigInt;\nexport const parseU128 = parseAsBigInt;\nexport const parseUsize = parseAsBigInt;\n\nexport function parseU256(data: readonly FieldElement[], offset: number) {\n  assertInBounds(data, offset + 1);\n  return {\n    out: BigInt(data[offset]) + (BigInt(data[offset + 1]) << 128n),\n    offset: offset + 2,\n  };\n}\n\nexport function parseAsHex(data: readonly FieldElement[], offset: number) {\n  assertInBounds(data, offset);\n  return {\n    out: data[offset],\n    offset: offset + 1,\n  };\n}\n\nexport const parseContractAddress = parseAsHex;\nexport const parseEthAddress = parseAsHex;\nexport const parseStorageAddress = parseAsHex;\nexport const parseClassHash = parseAsHex;\nexport const parseBytes31 = parseAsHex;\n\nexport function parseFelt252(data: readonly FieldElement[], offset: number) {\n  assertInBounds(data, offset);\n  return {\n    out: BigInt(data[offset]),\n    offset: offset + 1,\n  };\n}\n\nexport function parseEmpty(_data: readonly FieldElement[], offset: number) {\n  return { out: null, offset };\n}\n\n// Higher-level types.\n\nexport function parseArray<T>(type: Parser<T>): Parser<T[]> {\n  return (data: readonly FieldElement[], startingOffset: number) => {\n    let offset = startingOffset;\n    const length = BigInt(data[offset]);\n\n    offset++;\n\n    const out: T[] = [];\n    for (let i = 0; i < length; i++) {\n      const { out: item, offset: newOffset } = type(data, offset);\n      out.push(item);\n      offset = newOffset;\n    }\n\n    return { out, offset };\n  };\n}\n\nexport const parseSpan = parseArray;\n\nexport function parseOption<T>(type: Parser<T>) {\n  return (data: readonly FieldElement[], offset: number) => {\n    const hasValue = BigInt(data[offset]) === 1n;\n    if (hasValue) {\n      return type(data, offset + 1);\n    }\n    return { out: null, offset: offset + 1 };\n  };\n}\n\nexport function parseStruct<T extends Record<string, unknown>>(\n  parsers: {\n    [K in keyof T]: { index: number; parser: Parser<T[K]> };\n  },\n): Parser<{ [K in keyof T]: T[K] }> {\n  const sortedParsers = Object.entries(parsers).sort(\n    (a, b) => a[1].index - b[1].index,\n  );\n  const parser = (data: readonly FieldElement[], startingOffset: number) => {\n    let offset = startingOffset;\n    const out: Record<string, unknown> = {};\n    for (const [key, { parser }] of sortedParsers) {\n      const { out: value, offset: newOffset } = parser(data, offset);\n      out[key] = value;\n      offset = newOffset;\n    }\n    return { out, offset };\n  };\n  return parser as Parser<{ [K in keyof T]: T[K] }>;\n}\n\nexport function parseEnum<T extends Record<string, unknown>>(\n  parsers: {\n    [K in keyof T]: { index: number; parser: Parser<T[K]> };\n  },\n): Parser<T[keyof T]> {\n  return (data: readonly FieldElement[], startingOffset: number) => {\n    const selectorFelt = data[startingOffset];\n    const selector = Number(BigInt(selectorFelt));\n\n    // Find the parser by index\n    const parserEntry = Object.entries(parsers).find(\n      ([, { index }]) => index === selector,\n    );\n\n    if (!parserEntry) {\n      throw new ParseError(`Unknown enum variant selector: ${selector}`);\n    }\n\n    const [variantName, { parser }] = parserEntry;\n    const { out, offset: newOffset } = parser(data, startingOffset + 1);\n\n    return {\n      out: { _tag: variantName, [variantName]: out } as T[keyof T],\n      offset: newOffset,\n    };\n  };\n}\n\nexport function parseTuple<T extends Parser<unknown>[]>(\n  ...parsers: T\n): Parser<UnwrapParsers<T>> {\n  return (data: readonly FieldElement[], startingOffset: number) => {\n    let offset = startingOffset;\n    const out = [];\n    for (const parser of parsers) {\n      const { out: value, offset: newOffset } = parser(data, offset);\n      out.push(value);\n      offset = newOffset;\n    }\n    return { out, offset } as { out: UnwrapParsers<T>; offset: number };\n  };\n}\n\ntype UnwrapParsers<TP> = {\n  [Index in keyof TP]: TP[Index] extends Parser<infer U> ? U : never;\n};\n\nconst parseByteArrayStruct = parseStruct({\n  data: {\n    index: 0,\n    parser: parseArray(parseBytes31),\n  },\n  pendingWord: { index: 1, parser: parseFelt252 },\n  pendingWordLen: { index: 2, parser: parseU32 },\n});\n\nexport function parseByteArray(data: readonly FieldElement[], offset: number) {\n  // A ByteArray is a struct with the following abi:\n  //\n  // {\n  //   name: \"core::byte_array::ByteArray\",\n  //   type: \"struct\",\n  //   members: [\n  //     {\n  //       name: \"data\",\n  //       type: \"core::array::Array::<core::bytes_31::bytes31>\",\n  //     },\n  //     {\n  //       name: \"pending_word\",\n  //       type: \"core::felt252\",\n  //     },\n  //     {\n  //       name: \"pending_word_len\",\n  //       type: \"core::integer::u32\",\n  //     },\n  //   ],\n  // },\n  //\n  // We first parse it using a parser for that struct, then convert it to the output `0x${string}` type.\n  const { out, offset: offsetOut } = parseByteArrayStruct(data, offset);\n\n  // Remove 0x prefix from data elements and pad them to 31 bytes.\n  const dataBytes = out.data\n    .map((bytes) => bytes.slice(2).padStart(62, \"0\"))\n    .join(\"\");\n\n  let pending = out.pendingWord.toString(16);\n  const pendingWordLength = Number(out.pendingWordLen);\n  if (pending.length < pendingWordLength * 2) {\n    pending = pending.padStart(pendingWordLength * 2, \"0\");\n  }\n\n  const pendingBytes = pending.slice(pending.length - 2 * pendingWordLength);\n  const bytes = removeLeadingZeros(dataBytes + pendingBytes);\n\n  return { out: `0x${bytes}`, offset: offsetOut };\n}\n\nfunction removeLeadingZeros(bytes: string): string {\n  for (let i = 0; i < bytes.length; i++) {\n    if (bytes[i] !== \"0\") {\n      let j = i;\n      if (i % 2 !== 0) {\n        j -= 1;\n      }\n      return bytes.slice(j);\n    }\n  }\n  // The bytes are all 0, so return something reasonable.\n  return \"00\";\n}\n"],"names":["parser","bytes"],"mappings":"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"}