{"version":3,"file":"index.cjs","sources":["../src/utils.ts","../src/helper.ts","../src/persistence.ts","../src/storage.ts","../src/index.ts"],"sourcesContent":["import type {\n  ExtractTablesWithRelations,\n  TablesRelationalConfig,\n} from \"drizzle-orm\";\nimport type {\n  PgDatabase,\n  PgQueryResultHKT,\n  PgTransaction,\n} from \"drizzle-orm/pg-core\";\n\nexport class DrizzleStorageError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(message, options);\n    this.name = \"DrizzleStorageError\";\n  }\n}\n\nexport async function withTransaction<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(\n  db: PgDatabase<TQueryResult, TFullSchema, TSchema>,\n  cb: (db: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<void>,\n) {\n  return await db.transaction(async (txnDb) => {\n    return await cb(txnDb);\n  });\n}\n\nexport function deserialize<T>(str: string): T {\n  return JSON.parse(str, (_, value) =>\n    typeof value === \"string\" && value.match(/^\\d+n$/)\n      ? BigInt(value.slice(0, -1))\n      : value,\n  ) as T;\n}\n\nexport function serialize<T>(obj: T): string {\n  return JSON.stringify(\n    obj,\n    (_, value) => (typeof value === \"bigint\" ? `${value.toString()}n` : value),\n    \"\\t\",\n  );\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport interface IdColumnMap extends Record<string, string> {\n  /**\n   * Wildcard mapping for all tables.\n   */\n  \"*\": string;\n}\n\nexport const getIdColumnForTable = (\n  tableName: string,\n  idColumn: IdColumnMap,\n): string => {\n  // If there's a specific mapping for this table, use it\n  if (idColumn[tableName]) {\n    return idColumn[tableName];\n  }\n  // Default fallback\n  return idColumn[\"*\"];\n};\n","import type { PGlite, PGliteOptions } from \"@electric-sql/pglite\";\nimport type { DrizzleConfig } from \"drizzle-orm\";\nimport { entityKind } from \"drizzle-orm\";\nimport type { MigrationConfig } from \"drizzle-orm/migrator\";\nimport type { NodePgDatabase as OriginalNodePgDatabase } from \"drizzle-orm/node-postgres\";\nimport type { PgliteDatabase as OriginalPgliteDatabase } from \"drizzle-orm/pglite\";\nimport type pg from \"pg\";\nimport { DrizzleStorageError } from \"./utils\";\n\n/**\n * Union type of all possible drizzle database options\n */\nexport type DrizzleOptions = PgliteDrizzleOptions | NodePgDrizzleOptions;\n\n/**\n * Configuration options for Node-Postgres database connection\n */\nexport type NodePgDrizzleOptions = {\n  /**\n   * Type of database to use -\n   * - \"pglite\" - PGLite database\n   * - \"node-postgres\" - Node-Postgres database\n   * @default \"pglite\"\n   */\n  type: \"node-postgres\";\n  /**\n   * Connection string to use for the database\n   * @default \"\"\n   */\n  connectionString?: string;\n  /**\n   * Pool configuration options for Node-Postgres\n   */\n  poolConfig?: pg.PoolConfig;\n  /**\n   * Additional drizzle configuration options\n   */\n  config?: Omit<DrizzleConfig, \"schema\">;\n};\n\n/**\n * Configuration options for PGLite database connection\n */\nexport type PgliteDrizzleOptions = {\n  /**\n   * Type of database to use -\n   * - \"pglite\" - PGLite database\n   * - \"node-postgres\" - Node-Postgres database\n   */\n  type?: \"pglite\";\n  /**\n   * Connection string to use for the database\n   * @default process.env[\"POSTGRES_CONNECTION_STRING\"] ?? \"memory://pglite\"\n   */\n  connectionString?: string;\n  /**\n   * Pool configuration is not supported for PGLite\n   */\n  poolConfig?: never;\n  /**\n   * Additional drizzle configuration options with PGLite specific connection options\n   */\n  config?: Omit<DrizzleConfig, \"schema\"> & {\n    connection?:\n      | (PGliteOptions & {\n          dataDir?: string;\n        })\n      | string;\n  };\n};\n\n/**\n * Extended PGLite database type with client information\n */\nexport type PgliteDatabase<TSchema extends Record<string, unknown>> =\n  OriginalPgliteDatabase<TSchema> & {\n    $client: PGlite;\n  };\n\n/**\n * Extended Node-Postgres database type with client information\n */\nexport type NodePgDatabase<TSchema extends Record<string, unknown>> =\n  OriginalNodePgDatabase<TSchema> & {\n    $client: pg.Pool;\n  };\n\nexport type Database<\n  TOptions extends DrizzleOptions,\n  TSchema extends Record<string, unknown>,\n> = TOptions extends PgliteDrizzleOptions\n  ? PgliteDatabase<TSchema>\n  : NodePgDatabase<TSchema>;\n\n/**\n * Creates a new Drizzle database instance based on the provided options\n *\n * @important connectionString defaults to process.env[\"POSTGRES_CONNECTION_STRING\"], if not set, it defaults to \"memory://\" (in-memory pglite)\n *\n * @param options - Configuration options for the database connection\n * @returns A configured Drizzle database instance\n * @throws {Error} If an invalid database type is specified\n */\nexport function drizzle<\n  TSchema extends Record<string, unknown>,\n  TOptions extends DrizzleOptions,\n>(\n  options?: TOptions & {\n    /**\n     * Schema to use for the database\n     * @default {}\n     */\n    schema?: TSchema;\n  },\n): Database<TOptions, TSchema> {\n  const {\n    connectionString = process.env[\"POSTGRES_CONNECTION_STRING\"] ?? \"memory://\",\n    schema,\n    type = \"pglite\",\n    config,\n    poolConfig,\n  } = options ?? {};\n\n  if (isPgliteConnectionString(connectionString) && type === \"pglite\") {\n    const { drizzle: drizzlePGLite } = require(\"drizzle-orm/pglite\");\n\n    return drizzlePGLite({\n      schema: schema as TSchema,\n      connection: {\n        dataDir: connectionString || \"memory://pglite\",\n      },\n      ...(config || {}),\n    }) as Database<TOptions, TSchema>;\n  }\n\n  const { Pool } = require(\"pg\");\n  const { drizzle: drizzleNode } = require(\"drizzle-orm/node-postgres\");\n  const pool = new Pool({\n    connectionString,\n    ...(poolConfig || {}),\n  });\n  return drizzleNode(pool, { schema, ...(config || {}) }) as Database<\n    TOptions,\n    TSchema\n  >;\n}\n\n/**\n * Options for database migration\n */\nexport type MigrateOptions = MigrationConfig;\n\n/**\n * Performs database migration based on the provided configuration\n * @param db - The database instance to migrate\n * @param options - Migration configuration options\n *\n * @important This function runs migrations on the database instance provided to the `drizzleStorage` plugin.\n * It automatically detects the type of database and runs the appropriate migrate function\n * (PGLite or Node-Postgres).\n *\n * @example\n * ```ts\n * await migrate(db, { migrationsFolder: \"./drizzle\" });\n * ```\n */\nexport async function migrate<TSchema extends Record<string, unknown>>(\n  db: PgliteDatabase<TSchema> | NodePgDatabase<TSchema>,\n  options: MigrateOptions,\n) {\n  const isPglite = isDrizzleKind(db, \"PgliteDatabase\");\n\n  try {\n    if (isPglite) {\n      const { migrate: migratePGLite } = require(\"drizzle-orm/pglite/migrator\");\n      await migratePGLite(db as PgliteDatabase<TSchema>, options);\n    } else {\n      const {\n        migrate: migrateNode,\n      } = require(\"drizzle-orm/node-postgres/migrator\");\n      await migrateNode(db as NodePgDatabase<TSchema>, options);\n    }\n  } catch (error) {\n    throw new DrizzleStorageError(\n      \"Failed to apply migrations! Please check if you have generated migrations using drizzle:generate\",\n      {\n        cause: error,\n      },\n    );\n  }\n}\n\nfunction isPgliteConnectionString(conn: string) {\n  return (\n    conn.startsWith(\"memory://\") ||\n    conn.startsWith(\"file://\") ||\n    conn.startsWith(\"idb://\")\n  );\n}\n\nfunction isDrizzleKind(value: unknown, entityKindValue: string) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  // https://github.com/drizzle-team/drizzle-orm/blob/f39f885779800982e90dd3c89aba6df3217a6fd2/drizzle-orm/src/entity.ts#L29-L41\n  let cls = Object.getPrototypeOf(value).constructor;\n  if (cls) {\n    // Traverse the prototype chain to find the entityKind\n    while (cls) {\n      // https://github.com/drizzle-team/drizzle-orm/blob/f39f885779800982e90dd3c89aba6df3217a6fd2/drizzle-orm/src/pglite/driver.ts#L41\n      if (entityKind in cls && cls[entityKind] === entityKindValue) {\n        return true;\n      }\n      cls = Object.getPrototypeOf(cls);\n    }\n  }\n\n  return false;\n}\n","import { type Cursor, normalizeCursor } from \"@apibara/protocol\";\nimport { and, eq, gt, isNull, lt, sql } from \"drizzle-orm\";\nimport type {\n  ExtractTablesWithRelations,\n  TablesRelationalConfig,\n} from \"drizzle-orm\";\nimport type { PgQueryResultHKT, PgTransaction } from \"drizzle-orm/pg-core\";\nimport { integer, pgSchema, primaryKey, text } from \"drizzle-orm/pg-core\";\nimport { SCHEMA_NAME } from \"./constants\";\nimport { DrizzleStorageError, deserialize, serialize } from \"./utils\";\n\nconst CHECKPOINTS_TABLE_NAME = \"checkpoints\";\nconst FILTERS_TABLE_NAME = \"filters\";\nconst SCHEMA_VERSION_TABLE_NAME = \"schema_version\";\n\nconst schema = pgSchema(SCHEMA_NAME);\n\n/** This table is not used for migrations, its only used for ease of internal operations with drizzle. */\nexport const checkpoints = schema.table(CHECKPOINTS_TABLE_NAME, {\n  id: text(\"id\").notNull().primaryKey(),\n  orderKey: integer(\"order_key\").notNull(),\n  uniqueKey: text(\"unique_key\"),\n});\n\n/** This table is not used for migrations, its only used for ease of internal operations with drizzle. */\nexport const filters = schema.table(\n  FILTERS_TABLE_NAME,\n  {\n    id: text(\"id\").notNull(),\n    filter: text(\"filter\").notNull(),\n    fromBlock: integer(\"from_block\").notNull(),\n    toBlock: integer(\"to_block\").$type<number | null>().default(null),\n  },\n  (table) => [\n    {\n      pk: primaryKey({ columns: [table.id, table.fromBlock] }),\n    },\n  ],\n);\n\n/** This table is not used for migrations, its only used for ease of internal operations with drizzle. */\nexport const schemaVersion = schema.table(SCHEMA_VERSION_TABLE_NAME, {\n  k: integer(\"k\").notNull().primaryKey(),\n  version: integer(\"version\").notNull(),\n});\n\nexport const CURRENT_SCHEMA_VERSION = 0;\n\n// migrations for future schema updates\nconst MIGRATIONS: string[][] = [\n  // migrations[0]: v0 -> v1 (for future use)\n  [],\n  // Add more migration arrays for future versions\n];\n\nexport async function initializePersistentState<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) {\n  // Create schema if it doesn't exist\n  await tx.execute(\n    sql.raw(`\n      CREATE SCHEMA IF NOT EXISTS ${SCHEMA_NAME};\n  `),\n  );\n\n  // Create schema version table\n  await tx.execute(\n    sql.raw(`\n    CREATE TABLE IF NOT EXISTS ${SCHEMA_NAME}.${SCHEMA_VERSION_TABLE_NAME} (\n      k INTEGER PRIMARY KEY,\n      version INTEGER NOT NULL\n    );\n  `),\n  );\n\n  // Get current schema version\n  const versionRows = await tx\n    .select()\n    .from(schemaVersion)\n    .where(eq(schemaVersion.k, 0));\n\n  const storedVersion = versionRows[0]?.version ?? -1;\n\n  // Check for incompatible version\n  if (storedVersion > CURRENT_SCHEMA_VERSION) {\n    throw new DrizzleStorageError(\n      `Database Persistence schema version v${storedVersion} is newer than supported version v${CURRENT_SCHEMA_VERSION}`,\n    );\n  }\n\n  // Begin schema updates\n  try {\n    if (storedVersion === -1) {\n      // First time initialization\n      await tx.execute(\n        sql.raw(`\n        CREATE TABLE IF NOT EXISTS ${SCHEMA_NAME}.${CHECKPOINTS_TABLE_NAME} (\n          id TEXT PRIMARY KEY,\n          order_key INTEGER NOT NULL,\n          unique_key TEXT\n        );\n      `),\n      );\n\n      await tx.execute(\n        sql.raw(`\n        CREATE TABLE IF NOT EXISTS ${SCHEMA_NAME}.${FILTERS_TABLE_NAME} (\n          id TEXT NOT NULL,\n          filter TEXT NOT NULL,\n          from_block INTEGER NOT NULL,\n          to_block INTEGER DEFAULT NULL,\n          PRIMARY KEY (id, from_block)\n        );\n      `),\n      );\n\n      // Set initial schema version\n      await tx.insert(schemaVersion).values({\n        k: 0,\n        version: CURRENT_SCHEMA_VERSION,\n      });\n    } else {\n      // Run any necessary migrations\n      let currentVersion = storedVersion;\n      while (currentVersion < CURRENT_SCHEMA_VERSION) {\n        const migrationStatements = MIGRATIONS[currentVersion];\n        for (const statement of migrationStatements) {\n          await tx.execute(statement);\n        }\n        currentVersion++;\n      }\n\n      // Update schema version\n      await tx\n        .update(schemaVersion)\n        .set({ version: CURRENT_SCHEMA_VERSION })\n        .where(eq(schemaVersion.k, 0));\n    }\n  } catch (error) {\n    throw new DrizzleStorageError(\n      \"Failed to initialize or migrate database schema\",\n      { cause: error },\n    );\n  }\n}\n\nexport async function persistState<\n  TFilter,\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(props: {\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>;\n  endCursor: Cursor;\n  filter?: TFilter;\n  indexerId: string;\n}) {\n  const { tx, endCursor, filter, indexerId } = props;\n\n  try {\n    if (endCursor) {\n      await tx\n        .insert(checkpoints)\n        .values({\n          id: indexerId,\n          orderKey: Number(endCursor.orderKey),\n          uniqueKey: endCursor.uniqueKey,\n        })\n        .onConflictDoUpdate({\n          target: checkpoints.id,\n          set: {\n            orderKey: Number(endCursor.orderKey),\n            // Explicitly set the unique key to `null` to indicate that it has been deleted\n            // Otherwise drizzle will not update its value.\n            uniqueKey: endCursor.uniqueKey ? endCursor.uniqueKey : null,\n          },\n        });\n\n      if (filter) {\n        await tx\n          .update(filters)\n          .set({ toBlock: Number(endCursor.orderKey) })\n          .where(and(eq(filters.id, indexerId), isNull(filters.toBlock)));\n\n        await tx\n          .insert(filters)\n          .values({\n            id: indexerId,\n            filter: serialize(filter),\n            fromBlock: Number(endCursor.orderKey),\n            toBlock: null,\n          })\n          .onConflictDoUpdate({\n            target: [filters.id, filters.fromBlock],\n            set: {\n              filter: serialize(filter),\n              fromBlock: Number(endCursor.orderKey),\n              toBlock: null,\n            },\n          });\n      }\n    }\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to persist state\", {\n      cause: error,\n    });\n  }\n}\n\nexport async function getState<\n  TFilter,\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(props: {\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>;\n  indexerId: string;\n}): Promise<{ cursor?: Cursor; filter?: TFilter }> {\n  const { tx, indexerId } = props;\n\n  try {\n    const checkpointRows = await tx\n      .select()\n      .from(checkpoints)\n      .where(eq(checkpoints.id, indexerId));\n\n    const cursor = checkpointRows[0]\n      ? normalizeCursor({\n          orderKey: BigInt(checkpointRows[0].orderKey),\n          uniqueKey: checkpointRows[0].uniqueKey,\n        })\n      : undefined;\n\n    const filterRows = await tx\n      .select()\n      .from(filters)\n      .where(and(eq(filters.id, indexerId), isNull(filters.toBlock)));\n\n    const filter = filterRows[0]\n      ? deserialize<TFilter>(filterRows[0].filter)\n      : undefined;\n\n    return { cursor, filter };\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to get persistent state\", {\n      cause: error,\n    });\n  }\n}\n\nexport async function invalidateState<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(props: {\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>;\n  cursor: Cursor;\n  indexerId: string;\n}) {\n  const { tx, cursor, indexerId } = props;\n\n  try {\n    await tx\n      .delete(filters)\n      .where(\n        and(\n          eq(filters.id, indexerId),\n          gt(filters.fromBlock, Number(cursor.orderKey)),\n        ),\n      );\n\n    await tx\n      .update(filters)\n      .set({ toBlock: null })\n      .where(\n        and(\n          eq(filters.id, indexerId),\n          gt(filters.toBlock, Number(cursor.orderKey)),\n        ),\n      );\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to invalidate state\", {\n      cause: error,\n    });\n  }\n}\n\nexport async function finalizeState<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(props: {\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>;\n  cursor: Cursor;\n  indexerId: string;\n}) {\n  const { tx, cursor, indexerId } = props;\n\n  try {\n    await tx\n      .delete(filters)\n      .where(\n        and(\n          eq(filters.id, indexerId),\n          lt(filters.toBlock, Number(cursor.orderKey)),\n        ),\n      );\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to finalize state\", {\n      cause: error,\n    });\n  }\n}\n\nexport async function resetPersistence<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(props: {\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>;\n  indexerId: string;\n}) {\n  const { tx, indexerId } = props;\n\n  try {\n    await tx.delete(checkpoints).where(eq(checkpoints.id, indexerId));\n    await tx.delete(filters).where(eq(filters.id, indexerId));\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to reset persistence state\", {\n      cause: error,\n    });\n  }\n}\n","import type { Cursor } from \"@apibara/protocol\";\nimport {\n  type ExtractTablesWithRelations,\n  type TablesRelationalConfig,\n  sql,\n} from \"drizzle-orm\";\nimport {\n  type PgDatabase,\n  type PgQueryResultHKT,\n  type PgTransaction,\n  char,\n  integer,\n  jsonb,\n  pgSchema,\n  serial,\n  text,\n} from \"drizzle-orm/pg-core\";\nimport { SCHEMA_NAME } from \"./constants\";\nimport {\n  DrizzleStorageError,\n  type IdColumnMap,\n  getIdColumnForTable,\n} from \"./utils\";\n\nconst ROLLBACK_TABLE_NAME = \"reorg_rollback\";\n\nconst schema = pgSchema(SCHEMA_NAME);\n\nfunction getReorgTriggerName(table: string, indexerId: string) {\n  return `${table}_reorg_${indexerId}`;\n}\n\nexport type ReorgOperation = \"I\" | \"U\" | \"D\";\n\n/** This table is not used for migrations, its only used for ease of internal operations with drizzle. */\nexport const reorgRollbackTable = schema.table(ROLLBACK_TABLE_NAME, {\n  n: serial(\"n\").primaryKey(),\n  op: char(\"op\", { length: 1 }).$type<ReorgOperation>().notNull(),\n  table_name: text(\"table_name\").notNull(),\n  cursor: integer(\"cursor\").notNull(),\n  row_id: text(\"row_id\"),\n  row_value: jsonb(\"row_value\"),\n  indexer_id: text(\"indexer_id\").notNull(),\n});\n\nexport type ReorgRollbackRow = typeof reorgRollbackTable.$inferSelect;\n\nexport async function initializeReorgRollbackTable<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(tx: PgTransaction<TQueryResult, TFullSchema, TSchema>, indexerId: string) {\n  try {\n    // Create schema if it doesn't exist\n    await tx.execute(`\n    CREATE SCHEMA IF NOT EXISTS ${SCHEMA_NAME};\n    `);\n    // Create the audit log table\n    await tx.execute(\n      sql.raw(`\n        CREATE TABLE IF NOT EXISTS ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}(\n          n SERIAL PRIMARY KEY,\n          op CHAR(1) NOT NULL,\n          table_name TEXT NOT NULL,\n          cursor INTEGER NOT NULL,\n          row_id TEXT,\n          row_value JSONB,\n          indexer_id TEXT NOT NULL\n        );\n      `),\n    );\n\n    await tx.execute(\n      sql.raw(`\n        CREATE INDEX IF NOT EXISTS idx_reorg_rollback_indexer_id_cursor ON ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}(indexer_id, cursor);\n      `),\n    );\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to initialize reorg rollback table\", {\n      cause: error,\n    });\n  }\n\n  try {\n    // Create the trigger function\n    await tx.execute(\n      sql.raw(`\n      CREATE OR REPLACE FUNCTION ${SCHEMA_NAME}.reorg_checkpoint()\n      RETURNS TRIGGER AS $$\n      DECLARE\n        table_name TEXT := TG_ARGV[0]::TEXT;\n        id_col TEXT := TG_ARGV[1]::TEXT;\n        order_key INTEGER := TG_ARGV[2]::INTEGER;\n        indexer_id TEXT := TG_ARGV[3]::TEXT;\n        new_id_value TEXT := row_to_json(NEW.*)->>id_col;\n        old_id_value TEXT := row_to_json(OLD.*)->>id_col;\n      BEGIN\n        IF (TG_OP = 'DELETE') THEN\n          INSERT INTO ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}(op, table_name, cursor, row_id, row_value, indexer_id)\n            SELECT 'D', table_name, order_key, old_id_value, row_to_json(OLD.*), indexer_id;\n        ELSIF (TG_OP = 'UPDATE') THEN\n          INSERT INTO ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}(op, table_name, cursor, row_id, row_value, indexer_id)\n            SELECT 'U', table_name, order_key, new_id_value, row_to_json(OLD.*), indexer_id;\n        ELSIF (TG_OP = 'INSERT') THEN\n          INSERT INTO ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}(op, table_name, cursor, row_id, row_value, indexer_id)\n            SELECT 'I', table_name, order_key, new_id_value, null, indexer_id;\n        END IF;\n        RETURN NULL;\n      END;\n      $$ LANGUAGE plpgsql;\n    `),\n    );\n  } catch (error) {\n    throw new DrizzleStorageError(\n      \"Failed to create reorg checkpoint function\",\n      {\n        cause: error,\n      },\n    );\n  }\n}\n\nexport async function registerTriggers<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>,\n  tables: string[],\n  endCursor: Cursor,\n  idColumnMap: IdColumnMap,\n  indexerId: string,\n) {\n  try {\n    for (const table of tables) {\n      // Determine the column ID for this specific table\n      const tableIdColumn = getIdColumnForTable(table, idColumnMap);\n\n      await tx.execute(\n        sql.raw(\n          `DROP TRIGGER IF EXISTS ${getReorgTriggerName(table, indexerId)} ON ${table};`,\n        ),\n      );\n      await tx.execute(\n        sql.raw(`\n          CREATE CONSTRAINT TRIGGER ${getReorgTriggerName(table, indexerId)}\n          AFTER INSERT OR UPDATE OR DELETE ON ${table}\n          DEFERRABLE INITIALLY DEFERRED\n          FOR EACH ROW EXECUTE FUNCTION ${SCHEMA_NAME}.reorg_checkpoint('${table}', '${tableIdColumn}', ${Number(endCursor.orderKey)}, '${indexerId}');\n        `),\n      );\n    }\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to register triggers\", {\n      cause: error,\n    });\n  }\n}\n\nexport async function removeTriggers<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(\n  db: PgDatabase<TQueryResult, TFullSchema, TSchema>,\n  tables: string[],\n  indexerId: string,\n) {\n  try {\n    for (const table of tables) {\n      await db.execute(\n        sql.raw(\n          `DROP TRIGGER IF EXISTS ${getReorgTriggerName(table, indexerId)} ON ${table};`,\n        ),\n      );\n    }\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to remove triggers\", {\n      cause: error,\n    });\n  }\n}\n\nexport async function invalidate<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>,\n  cursor: Cursor,\n  idColumnMap: IdColumnMap,\n  indexerId: string,\n) {\n  // Get and delete operations after cursor in one query, ordered by newest first\n  const { rows: result } = (await tx.execute(\n    sql.raw(`\n      WITH deleted AS (\n        DELETE FROM ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}\n        WHERE cursor > ${Number(cursor.orderKey)}\n        AND indexer_id = '${indexerId}'\n        RETURNING *\n      )\n      SELECT * FROM deleted ORDER BY n DESC;\n    `),\n  )) as { rows: ReorgRollbackRow[] };\n\n  if (!Array.isArray(result)) {\n    throw new DrizzleStorageError(\n      \"Invalid result format from reorg_rollback query\",\n    );\n  }\n\n  // Process each operation in reverse order\n  for (const op of result) {\n    // Determine the column ID for this specific table\n    const tableIdColumn = getIdColumnForTable(op.table_name, idColumnMap);\n\n    switch (op.op) {\n      case \"I\":\n        try {\n          if (!op.row_id) {\n            throw new DrizzleStorageError(\"Insert operation has no row_id\");\n          }\n\n          await tx.execute(\n            sql.raw(`\n                DELETE FROM ${op.table_name}\n                WHERE ${tableIdColumn} = '${op.row_id}'\n              `),\n          );\n        } catch (error) {\n          throw new DrizzleStorageError(\n            \"Failed to invalidate | Operation - I\",\n            {\n              cause: error,\n            },\n          );\n        }\n\n        break;\n\n      case \"D\":\n        try {\n          // For deletes, reinsert the row using json_populate_record\n          if (!op.row_value) {\n            throw new DrizzleStorageError(\"Delete operation has no row_value\");\n          }\n\n          await tx.execute(\n            sql.raw(`\n              INSERT INTO ${op.table_name}\n              SELECT * FROM json_populate_record(null::${op.table_name}, '${JSON.stringify(op.row_value)}'::json)\n            `),\n          );\n        } catch (error) {\n          throw new DrizzleStorageError(\n            \"Failed to invalidate | Operation - D\",\n            {\n              cause: error,\n            },\n          );\n        }\n\n        break;\n\n      case \"U\":\n        try {\n          if (!op.row_value || !op.row_id) {\n            throw new DrizzleStorageError(\n              \"Update operation has no row_value or row_id\",\n            );\n          }\n\n          // For updates, restore previous values\n\n          const rowValue =\n            typeof op.row_value === \"string\"\n              ? JSON.parse(op.row_value)\n              : op.row_value;\n\n          const nonIdKeys = Object.keys(rowValue).filter(\n            (k) => k !== tableIdColumn,\n          );\n\n          const fields = nonIdKeys.map((c) => `${c} = prev.${c}`).join(\", \");\n\n          const query = sql.raw(`\n              UPDATE ${op.table_name}\n              SET ${fields}\n              FROM (\n                SELECT * FROM json_populate_record(null::${op.table_name}, '${JSON.stringify(op.row_value)}'::json)\n              ) as prev\n              WHERE ${op.table_name}.${tableIdColumn} = '${op.row_id}'\n              `);\n\n          await tx.execute(query);\n        } catch (error) {\n          throw new DrizzleStorageError(\n            \"Failed to invalidate | Operation - U\",\n            {\n              cause: error,\n            },\n          );\n        }\n        break;\n\n      default: {\n        throw new DrizzleStorageError(`Unknown operation: ${op.op}`);\n      }\n    }\n  }\n}\n\nexport async function finalize<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>,\n  cursor: Cursor,\n  indexerId: string,\n) {\n  try {\n    await tx.execute(\n      sql.raw(`\n      DELETE FROM ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}\n      WHERE cursor <= ${Number(cursor.orderKey)}\n      AND indexer_id = '${indexerId}'\n    `),\n    );\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to finalize\", {\n      cause: error,\n    });\n  }\n}\n\nexport async function cleanupStorage<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(\n  tx: PgTransaction<TQueryResult, TFullSchema, TSchema>,\n  tables: string[],\n  indexerId: string,\n) {\n  try {\n    for (const table of tables) {\n      await tx.execute(\n        sql.raw(\n          `DROP TRIGGER IF EXISTS ${getReorgTriggerName(table, indexerId)} ON ${table};`,\n        ),\n      );\n    }\n\n    await tx.execute(\n      sql.raw(`\n        DELETE FROM ${SCHEMA_NAME}.${ROLLBACK_TABLE_NAME}\n        WHERE indexer_id = '${indexerId}'\n      `),\n    );\n\n    for (const table of tables) {\n      try {\n        await tx.execute(sql.raw(`TRUNCATE TABLE ${table} CASCADE;`));\n      } catch (error) {\n        throw new DrizzleStorageError(`Failed to truncate table ${table}`, {\n          cause: error,\n        });\n      }\n    }\n  } catch (error) {\n    throw new DrizzleStorageError(\"Failed to clean up storage\", {\n      cause: error,\n    });\n  }\n}\n","import { useIndexerContext } from \"@apibara/indexer\";\nimport { defineIndexerPlugin, useLogger } from \"@apibara/indexer/plugins\";\n\nimport type {\n  ExtractTablesWithRelations,\n  TablesRelationalConfig,\n} from \"drizzle-orm\";\n\nimport { generateIndexerId } from \"@apibara/indexer/internal\";\nimport { useInternalContext } from \"@apibara/indexer/internal/plugins\";\nimport type { Cursor, DataFinality } from \"@apibara/protocol\";\nimport type {\n  PgDatabase,\n  PgQueryResultHKT,\n  PgTransaction,\n} from \"drizzle-orm/pg-core\";\nimport { DRIZZLE_PROPERTY, DRIZZLE_STORAGE_DB_PROPERTY } from \"./constants\";\nimport { type MigrateOptions, migrate } from \"./helper\";\nimport {\n  finalizeState,\n  getState,\n  initializePersistentState,\n  invalidateState,\n  persistState,\n  resetPersistence,\n} from \"./persistence\";\nimport {\n  cleanupStorage,\n  finalize,\n  initializeReorgRollbackTable,\n  invalidate,\n  registerTriggers,\n  removeTriggers,\n} from \"./storage\";\nimport {\n  DrizzleStorageError,\n  type IdColumnMap,\n  getIdColumnForTable,\n  sleep,\n  withTransaction,\n} from \"./utils\";\n\nexport * from \"./helper\";\n\nexport type { IdColumnMap };\n\nconst MAX_RETRIES = 5;\n\nexport type DrizzleStorage<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n> = {\n  db: PgTransaction<TQueryResult, TFullSchema, TSchema>;\n};\n\nexport function useDrizzleStorage<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>(\n  _db?: PgDatabase<TQueryResult, TFullSchema, TSchema>,\n): DrizzleStorage<TQueryResult, TFullSchema, TSchema> {\n  const context = useIndexerContext();\n\n  if (!context[DRIZZLE_PROPERTY]) {\n    throw new DrizzleStorageError(\n      \"drizzle storage is not available. Did you register the plugin?\",\n    );\n  }\n\n  return context[DRIZZLE_PROPERTY];\n}\n\nexport interface DrizzleStorageOptions<\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n> {\n  /**\n   * The Drizzle database instance.\n   */\n  db: PgDatabase<TQueryResult, TFullSchema, TSchema>;\n  /**\n   * Whether to persist the indexer's state. Defaults to true.\n   */\n  persistState?: boolean;\n  /**\n   * The name of the indexer. Default value is 'default'.\n   */\n  indexerName?: string;\n  /**\n   * The schema of the database.\n   */\n  schema?: Record<string, unknown>;\n  /**\n   * The column to use as the primary identifier for each table.\n   *\n   * This identifier is used for tracking changes during reorgs and rollbacks.\n   *\n   * Can be specified in two ways:\n   *\n   * 1. As a single string that applies to all tables:\n   * ```ts\n   * idColumn: \"_id\" // Uses \"_id\" column for all tables\n   * ```\n   *\n   * 2. As an object mapping table names to their ID columns:\n   * ```ts\n   * idColumn: {\n   *   transfers: \"transaction_hash\",    // Use \"transaction_hash\" for transfers table\n   *   blocks: \"block_number\",           // Use \"block_number\" for blocks table\n   *   \"*\": \"_id\"                        // Use \"_id\" for all other tables | defaults to \"id\"\n   * }\n   * ```\n   *\n   * The special \"*\" key acts as a fallback for any tables not explicitly mapped.\n   *\n   * @default \"id\"\n   * @type {string | Partial<IdColumnMap>}\n   */\n  idColumn?: string | Partial<IdColumnMap>;\n  /**\n   * The options for the database migration. When provided, the database will automatically run migrations before the indexer runs.\n   */\n  migrate?: MigrateOptions;\n}\n\n/**\n * Creates a plugin that uses Drizzle as the storage layer.\n *\n * Supports storing the indexer's state and provides a simple Key-Value store.\n * @param options.db - The Drizzle database instance.\n * @param options.persistState - Whether to persist the indexer's state. Defaults to true.\n * @param options.indexerName - The name of the indexer. Defaults value is 'default'.\n * @param options.schema - The schema of the database.\n * @param options.idColumn - The column to use as the id. Defaults to 'id'.\n * @param options.migrate - The options for the database migration. when provided, the database will automatically run migrations before the indexer runs.\n */\nexport function drizzleStorage<\n  TFilter,\n  TBlock,\n  TQueryResult extends PgQueryResultHKT,\n  TFullSchema extends Record<string, unknown> = Record<string, never>,\n  TSchema extends\n    TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n>({\n  db,\n  persistState: enablePersistence = true,\n  indexerName: identifier = \"default\",\n  schema: _schema,\n  idColumn,\n  migrate: migrateOptions,\n}: DrizzleStorageOptions<TQueryResult, TFullSchema, TSchema>) {\n  return defineIndexerPlugin<TFilter, TBlock>((indexer) => {\n    let tableNames: string[] = [];\n    let indexerId = \"\";\n    const alwaysReindex = process.env[\"APIBARA_ALWAYS_REINDEX\"] === \"true\";\n    let prevFinality: DataFinality | undefined;\n    const schema: TSchema = (_schema as TSchema) ?? db._.schema ?? {};\n    const idColumnMap: IdColumnMap = {\n      \"*\": typeof idColumn === \"string\" ? idColumn : \"id\",\n      ...(typeof idColumn === \"object\" ? idColumn : {}),\n    };\n\n    try {\n      tableNames = Object.values(schema).map((table) => table.dbName);\n    } catch (error) {\n      throw new DrizzleStorageError(\"Failed to get table names from schema\", {\n        cause: error,\n      });\n    }\n\n    // Check if specified idColumn exists in all the tables in schema\n    for (const table of Object.values(schema)) {\n      const columns = table.columns;\n      const tableIdColumn = getIdColumnForTable(table.dbName, idColumnMap);\n\n      const columnExists = Object.values(columns).some(\n        (column) => column.name === tableIdColumn,\n      );\n\n      if (!columnExists) {\n        throw new DrizzleStorageError(\n          `Column \\`\"${tableIdColumn}\"\\` does not exist in table \\`\"${table.dbName}\"\\`. ` +\n            \"Make sure the table has the specified column or provide a valid `idColumn` mapping to `drizzleStorage`.\",\n        );\n      }\n    }\n\n    indexer.hooks.hook(\"run:before\", async () => {\n      const internalContext = useInternalContext();\n      const context = useIndexerContext();\n      const logger = useLogger();\n\n      // For testing purposes using vcr.\n      context[DRIZZLE_STORAGE_DB_PROPERTY] = db;\n\n      const { indexerName: indexerFileName, availableIndexers } =\n        internalContext;\n\n      indexerId = generateIndexerId(indexerFileName, identifier);\n\n      let retries = 0;\n\n      // incase the migrations are already applied, we don't want to run them again\n      let migrationsApplied = false;\n      let cleanupApplied = false;\n\n      while (retries <= MAX_RETRIES) {\n        try {\n          if (migrateOptions && !migrationsApplied) {\n            // @ts-ignore type mismatch for db\n            await migrate(db, migrateOptions);\n            migrationsApplied = true;\n            logger.success(\"Migrations applied\");\n          }\n          await withTransaction(db, async (tx) => {\n            await initializeReorgRollbackTable(tx, indexerId);\n            if (enablePersistence) {\n              await initializePersistentState(tx);\n            }\n\n            if (alwaysReindex && !cleanupApplied) {\n              logger.warn(\n                `Reindexing: Deleting all data from tables - ${tableNames.join(\", \")}`,\n              );\n\n              await cleanupStorage(tx, tableNames, indexerId);\n\n              if (enablePersistence) {\n                await resetPersistence({ tx, indexerId });\n              }\n\n              cleanupApplied = true;\n\n              logger.success(\"Tables have been cleaned up for reindexing\");\n            }\n          });\n          break;\n        } catch (error) {\n          if (retries === MAX_RETRIES) {\n            if (error instanceof DrizzleStorageError) {\n              throw error;\n            }\n            throw new DrizzleStorageError(\n              \"Initialization failed after 5 retries\",\n              {\n                cause: error,\n              },\n            );\n          }\n          await sleep(retries * 1000);\n          retries++;\n        }\n      }\n    });\n\n    indexer.hooks.hook(\"connect:before\", async ({ request }) => {\n      if (!enablePersistence) {\n        return;\n      }\n\n      await withTransaction(db, async (tx) => {\n        const { cursor, filter } = await getState<\n          TFilter,\n          TQueryResult,\n          TFullSchema,\n          TSchema\n        >({\n          tx,\n          indexerId,\n        });\n        if (cursor) {\n          request.startingCursor = cursor;\n        }\n        if (filter) {\n          request.filter[1] = filter;\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"connect:after\", async ({ request }) => {\n      // On restart, we need to invalidate data for blocks that were processed but not persisted.\n      const cursor = request.startingCursor;\n\n      if (!cursor) {\n        return;\n      }\n\n      await withTransaction(db, async (tx) => {\n        // Use the appropriate idColumn for each table when calling invalidate\n        await invalidate(tx, cursor, idColumnMap, indexerId);\n\n        if (enablePersistence) {\n          await invalidateState({ tx, cursor, indexerId });\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"connect:factory\", async ({ request, endCursor }) => {\n      if (!enablePersistence) {\n        return;\n      }\n      // We can call this hook because this hook is called inside the transaction of handler:middleware\n      // so we have access to the transaction from the context\n      const { db: tx } = useDrizzleStorage(db);\n\n      if (endCursor && request.filter[1]) {\n        await persistState({\n          tx,\n          endCursor,\n          filter: request.filter[1],\n          indexerId,\n        });\n      }\n    });\n\n    indexer.hooks.hook(\"message:finalize\", async ({ message }) => {\n      const { cursor } = message;\n\n      if (!cursor) {\n        throw new DrizzleStorageError(\"Finalized Cursor is undefined\");\n      }\n\n      await withTransaction(db, async (tx) => {\n        await finalize(tx, cursor, indexerId);\n\n        if (enablePersistence) {\n          await finalizeState({ tx, cursor, indexerId });\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"message:invalidate\", async ({ message }) => {\n      const { cursor } = message;\n\n      if (!cursor) {\n        throw new DrizzleStorageError(\"Invalidate Cursor is undefined\");\n      }\n\n      await withTransaction(db, async (tx) => {\n        // Use the appropriate idColumn for each table when calling invalidate\n        await invalidate(tx, cursor, idColumnMap, indexerId);\n\n        if (enablePersistence) {\n          await invalidateState({ tx, cursor, indexerId });\n        }\n      });\n    });\n\n    indexer.hooks.hook(\"handler:middleware\", async ({ use }) => {\n      use(async (context, next) => {\n        try {\n          const { endCursor, finality, cursor } = context as {\n            cursor: Cursor;\n            endCursor: Cursor;\n            finality: DataFinality;\n          };\n\n          if (!endCursor) {\n            throw new DrizzleStorageError(\"End Cursor is undefined\");\n          }\n          \n          await withTransaction(db, async (tx) => {\n            context[DRIZZLE_PROPERTY] = { db: tx } as DrizzleStorage<\n              TQueryResult,\n              TFullSchema,\n              TSchema\n            >;\n            \n            if (prevFinality === \"pending\") {\n              // invalidate if previous block's finality was \"pending\"\n              await invalidate(tx, cursor, idColumnMap, indexerId);\n            }\n\n            if (finality !== \"finalized\") {\n              await registerTriggers(\n                tx,\n                tableNames,\n                endCursor,\n                idColumnMap,\n                indexerId,\n              );\n            }\n            delete context[DRIZZLE_PROPERTY];\n          })\n\n          await withTransaction(db, async (tx) => {\n            context[DRIZZLE_PROPERTY] = { db: tx } as DrizzleStorage<\n              TQueryResult,\n              TFullSchema,\n              TSchema\n            >;\n\n            await next();\n            delete context[DRIZZLE_PROPERTY];\n\n            if (enablePersistence && finality !== \"pending\") {\n              await persistState({\n                tx,\n                endCursor,\n                indexerId,\n              });\n            }\n\n            prevFinality = finality;\n          });\n\n          if (finality !== \"finalized\") {\n            // remove trigger outside of the transaction or it won't be triggered.\n            await removeTriggers(db, tableNames, indexerId);\n          }\n        } catch (error) {\n          await removeTriggers(db, tableNames, indexerId);\n\n          throw new DrizzleStorageError(\"Failed to run handler:middleware\", {\n            cause: error,\n          });\n        }\n      });\n    });\n  });\n}\n"],"names":["entityKind","schema","pgSchema","SCHEMA_NAME","text","integer","primaryKey","sql","eq","and","isNull","normalizeCursor","gt","lt","serial","char","jsonb","useIndexerContext","DRIZZLE_PROPERTY","defineIndexerPlugin","indexer","useInternalContext","useLogger","DRIZZLE_STORAGE_DB_PROPERTY","generateIndexerId"],"mappings":"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"}