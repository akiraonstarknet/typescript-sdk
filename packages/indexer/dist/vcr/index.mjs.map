{"version":3,"file":"index.mjs","sources":["../../src/vcr/helper.ts","../../src/vcr/record.ts","../../src/vcr/replay.ts"],"sourcesContent":["import fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { VcrConfig } from \"./config\";\n\nexport function deserialize(str: string) {\n  return JSON.parse(str, (_, value) =>\n    typeof value === \"string\" && value.match(/^\\d+n$/)\n      ? BigInt(value.slice(0, -1))\n      : value,\n  );\n}\n\nexport function serialize(obj: Record<string, unknown>): string {\n  return JSON.stringify(\n    obj,\n    (_, value) => (typeof value === \"bigint\" ? `${value.toString()}n` : value),\n    \"\\t\",\n  );\n}\n\nexport function isCassetteAvailable(\n  vcrConfig: VcrConfig,\n  cassetteName: string,\n): boolean {\n  const filePath = path.join(vcrConfig.cassetteDir, `${cassetteName}.json`);\n  return fs.existsSync(filePath);\n}\n","import fs from \"node:fs/promises\";\nimport path from \"node:path\";\nimport type { Client, StreamDataResponse } from \"@apibara/protocol\";\nimport { type Indexer, run } from \"../indexer\";\nimport type { CassetteOptions, VcrConfig } from \"./config\";\nimport { serialize } from \"./helper\";\n\nexport type CassetteDataType<TFilter, TBlock> = {\n  filter: TFilter;\n  messages: StreamDataResponse<TBlock>[];\n};\n\nexport async function record<TFilter, TBlock, TTxnParams>(\n  vcrConfig: VcrConfig,\n  client: Client<TFilter, TBlock>,\n  indexer: Indexer<TFilter, TBlock>,\n  cassetteOptions: CassetteOptions,\n) {\n  const messages: StreamDataResponse<TBlock>[] = [];\n\n  indexer.hooks.addHooks({\n    \"connect:before\"({ options, request }) {\n      request.startingCursor = cassetteOptions.startingCursor;\n      options.endingCursor = cassetteOptions.endingCursor;\n    },\n    message({ message }) {\n      messages.push(message);\n    },\n    async \"run:after\"() {\n      const output: CassetteDataType<TFilter, TBlock> = {\n        filter: indexer.options.filter,\n        messages: messages,\n      };\n\n      await fs.mkdir(vcrConfig.cassetteDir, { recursive: true });\n\n      const filePath = path.join(\n        vcrConfig.cassetteDir,\n        `${cassetteOptions.name}.json`,\n      );\n\n      await fs.writeFile(filePath, serialize(output), { flag: \"w\" });\n    },\n  });\n\n  await run(client, indexer);\n}\n","import assert from \"node:assert\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Client } from \"@apibara/protocol\";\nimport { MockClient } from \"@apibara/protocol/testing\";\nimport { type Indexer, run } from \"../indexer\";\nimport { type CassetteDataType, deserialize } from \"../vcr\";\nimport type { VcrConfig } from \"./config\";\n\nexport async function replay<TFilter, TBlock, TTxnParams>(\n  vcrConfig: VcrConfig,\n  indexer: Indexer<TFilter, TBlock>,\n  cassetteName: string,\n) {\n  const client = loadCassette<TFilter, TBlock>(vcrConfig, cassetteName);\n  await run(client, indexer);\n}\n\nexport function loadCassette<TFilter, TBlock>(\n  vcrConfig: VcrConfig,\n  cassetteName: string,\n): Client<TFilter, TBlock> {\n  const filePath = path.join(vcrConfig.cassetteDir, `${cassetteName}.json`);\n\n  const data = fs.readFileSync(filePath, \"utf8\");\n  const cassetteData: CassetteDataType<TFilter, TBlock> = deserialize(data);\n\n  const { filter, messages } = cassetteData;\n\n  return new MockClient<TFilter, TBlock>((request, options) => {\n    // Notice that the request filter is an array of filters,\n    // so we need to wrap the indexer filter in an array.\n    assert.deepStrictEqual(\n      request.filter,\n      [filter],\n      \"Indexer and cassette filter mismatch. Hint: delete the cassette and run again.\",\n    );\n\n    return messages;\n  });\n}\n"],"names":["fs"],"mappings":";;;;;;;;;;;;;;;AAIO,SAAS,YAAY,GAAa,EAAA;AACvC,EAAA,OAAO,IAAK,CAAA,KAAA;AAAA,IAAM,GAAA;AAAA,IAAK,CAAC,CAAG,EAAA,KAAA,KACzB,OAAO,KAAA,KAAU,YAAY,KAAM,CAAA,KAAA,CAAM,QAAQ,CAAA,GAC7C,OAAO,KAAM,CAAA,KAAA,CAAM,CAAG,EAAA,CAAA,CAAE,CAAC,CACzB,GAAA,KAAA;AAAA,GACN,CAAA;AACF,CAAA;AAEO,SAAS,UAAU,GAAsC,EAAA;AAC9D,EAAA,OAAO,IAAK,CAAA,SAAA;AAAA,IACV,GAAA;AAAA,IACA,CAAC,CAAG,EAAA,KAAA,KAAW,OAAO,KAAA,KAAU,WAAW,CAAG,EAAA,KAAA,CAAM,QAAS,EAAC,CAAM,CAAA,CAAA,GAAA,KAAA;AAAA,IACpE,GAAA;AAAA,GACF,CAAA;AACF,CAAA;AAEgB,SAAA,mBAAA,CACd,WACA,YACS,EAAA;AACT,EAAA,MAAM,WAAW,IAAK,CAAA,IAAA,CAAK,UAAU,WAAa,EAAA,CAAA,EAAG,YAAY,CAAO,KAAA,CAAA,CAAA,CAAA;AACxE,EAAO,OAAA,EAAA,CAAG,WAAW,QAAQ,CAAA,CAAA;AAC/B;;ACdA,eAAsB,MACpB,CAAA,SAAA,EACA,MACA,EAAA,OAAA,EACA,eACA,EAAA;AACA,EAAA,MAAM,WAAyC,EAAC,CAAA;AAEhD,EAAA,OAAA,CAAQ,MAAM,QAAS,CAAA;AAAA,IACrB,gBAAiB,CAAA,EAAE,OAAS,EAAA,OAAA,EAAW,EAAA;AACrC,MAAA,OAAA,CAAQ,iBAAiB,eAAgB,CAAA,cAAA,CAAA;AACzC,MAAA,OAAA,CAAQ,eAAe,eAAgB,CAAA,YAAA,CAAA;AAAA,KACzC;AAAA,IACA,OAAA,CAAQ,EAAE,OAAA,EAAW,EAAA;AACnB,MAAA,QAAA,CAAS,KAAK,OAAO,CAAA,CAAA;AAAA,KACvB;AAAA,IACA,MAAM,WAAc,GAAA;AAClB,MAAA,MAAM,MAA4C,GAAA;AAAA,QAChD,MAAA,EAAQ,QAAQ,OAAQ,CAAA,MAAA;AAAA,QACxB,QAAA;AAAA,OACF,CAAA;AAEA,MAAA,MAAMA,KAAG,KAAM,CAAA,SAAA,CAAU,aAAa,EAAE,SAAA,EAAW,MAAM,CAAA,CAAA;AAEzD,MAAA,MAAM,WAAW,IAAK,CAAA,IAAA;AAAA,QACpB,SAAU,CAAA,WAAA;AAAA,QACV,CAAA,EAAG,gBAAgB,IAAI,CAAA,KAAA,CAAA;AAAA,OACzB,CAAA;AAEA,MAAM,MAAAA,IAAA,CAAG,UAAU,QAAU,EAAA,SAAA,CAAU,MAAM,CAAG,EAAA,EAAE,IAAM,EAAA,GAAA,EAAK,CAAA,CAAA;AAAA,KAC/D;AAAA,GACD,CAAA,CAAA;AAED,EAAM,MAAA,GAAA,CAAI,QAAQ,OAAO,CAAA,CAAA;AAC3B;;ACrCsB,eAAA,MAAA,CACpB,SACA,EAAA,OAAA,EACA,YACA,EAAA;AACA,EAAM,MAAA,MAAA,GAAS,YAA8B,CAAA,SAAA,EAAW,YAAY,CAAA,CAAA;AACpE,EAAM,MAAA,GAAA,CAAI,QAAQ,OAAO,CAAA,CAAA;AAC3B,CAAA;AAEgB,SAAA,YAAA,CACd,WACA,YACyB,EAAA;AACzB,EAAA,MAAM,WAAW,IAAK,CAAA,IAAA,CAAK,UAAU,WAAa,EAAA,CAAA,EAAG,YAAY,CAAO,KAAA,CAAA,CAAA,CAAA;AAExE,EAAA,MAAM,IAAO,GAAA,EAAA,CAAG,YAAa,CAAA,QAAA,EAAU,MAAM,CAAA,CAAA;AAC7C,EAAM,MAAA,YAAA,GAAkD,YAAY,IAAI,CAAA,CAAA;AAExE,EAAM,MAAA,EAAE,MAAQ,EAAA,QAAA,EAAa,GAAA,YAAA,CAAA;AAE7B,EAAA,OAAO,IAAI,UAAA,CAA4B,CAAC,OAAA,EAAS,OAAY,KAAA;AAG3D,IAAO,MAAA,CAAA,eAAA;AAAA,MACL,OAAQ,CAAA,MAAA;AAAA,MACR,CAAC,MAAM,CAAA;AAAA,MACP,gFAAA;AAAA,KACF,CAAA;AAEA,IAAO,OAAA,QAAA,CAAA;AAAA,GACR,CAAA,CAAA;AACH;;;;"}